- [百度实习一面](#百度实习一面)
  - [项目相关](#项目相关)
    - [分布式一致性是什么？](#分布式一致性是什么)
    - [介绍一下raft协议](#介绍一下raft协议)
    - [负载均衡怎么实现？](#负载均衡怎么实现)
  - [八股](#八股)
    - [mysql框架，查一条数据的过程](#mysql框架查一条数据的过程)
    - [mysql数据落盘的过程](#mysql数据落盘的过程)
    - [介绍索引的机制](#介绍索引的机制)
    - [什么时候用索引，什么时候不用索引？](#什么时候用索引什么时候不用索引)
    - [什么时候回表？](#什么时候回表)
    - [介绍事务](#介绍事务)
    - [redolog和binlog的区别](#redolog和binlog的区别)
    - [没有binlog或者redolog会发生什么？](#没有binlog或者redolog会发生什么)
    - [mysql什么情况下存在主从延迟问题？](#mysql什么情况下存在主从延迟问题)
    - [c++和golang的区别](#c和golang的区别)
  - [算法](#算法)
    - [关键点](#关键点)

# 百度实习一面

## 项目相关

### 分布式一致性是什么？
CAP
一致性，可用性，分区容错性
AP和CP两种模型

补充：AP模型强调可用性和分区容错性，允许数据在不同节点之间不一致；CP模型强调一致性和分区容错性，要求在网络分区发生时牺牲可用性。  
一致性还可以分为强一致性和最终一致性，**强一致性要求所有节点在同一时间看到相同的数据(CP)**，而**最终一致性允许数据在一段时间内不一致，但最终会达到一致状态(AP)**。

### 介绍一下raft协议
半数选举leader节点
心跳
存在脑裂？

补充：
1. 选举机制：集群中的节点通过投票选举产生一个Leader节点，只有Leader可以处理客户端的写请求，其他节点作为Follower同步数据。
2. 日志复制：Leader接收客户端请求后，将日志条目复制到大多数节点（包括自己），只有大多数节点写入成功后才算提交。
3. 心跳机制：Leader会定期向Follower发送心跳，维持自己的领导地位，同时检测节点存活。
4. 故障恢复：如果Leader宕机，剩余节点会重新发起选举，保证系统可用性。
5. 脑裂问题：Raft通过大多数节点投票机制，避免出现多个Leader（脑裂）的问题。

### 负载均衡怎么实现？

- 轮询（Round Robin）：请求依次分配到后端服务器，适合服务器性能相近的场景。
- 随机（Random）：每次随机选择一台服务器，分布较为均匀。
- 一致性哈希（Consistent Hashing）：根据请求特征哈希分配，适合分布式缓存、会话保持等。

      一致性哈希的核心是：把整个 0 ~ 2³² − 1 的哈希空间首尾相接成环，将每台物理服务器（以及其若干虚拟节点）通过哈希函数映射成环上的坐标，然后对每个业务 Key 同样哈希后沿顺时针方向寻找第一个遇到的节点并存放数据。引入虚拟节点可把一台机器拆成多个坐标，使区段长度趋于均匀，从而避免“热点”与“冷点”。当新增节点时，它只“接管”自己位置到下一个节点之间那一小段数据；当节点下线时，它原先区段内的 Key 顺时针全部迁移到下一节点，环上其余映射保持不变，因此节点增删仅影响约 1/N 的数据迁移，既保证负载均衡，也最大程度减轻扩缩容带来的抖动。

- 加权轮询（Weighted Round Robin）：为每台服务器分配权重，权重高的服务器分配到的请求更多，适合服务器性能不均的场景。
- 最少连接数（Least Connections）：每次将新请求分配给当前连接数最少的服务器，适合请求处理时间差异较大的场景。

## 八股
### mysql框架，查一条数据的过程
server层
连接，分析，优化，执行 √
引擎层 对数据进行io，放入buffer中

补充：
Server层：

1. 连接管理：客户端与MySQL建立连接。
2. 语法解析：对SQL语句进行解析，生成执行计划。
3. 查询优化：优化器选择最优的执行方案。
4. 执行器：根据执行计划调用存储引擎接口。

存储引擎层（如InnoDB）：

1. 接收Server层的请求，访问数据页。
2. 如果数据在Buffer Pool（缓冲池）中，直接返回；否则从磁盘读取到Buffer Pool，再返回。
3. 如果需要修改数据，先在Buffer Pool中修改，然后记录到Redo Log（重做日志）和Binlog（二进制日志）。
4. 最终将结果返回给Server层，再返回给客户端

### mysql数据落盘的过程
先把数据读到buffer pool
redolog记录修改，
binlog记录执行命令
buffer pool标记脏页，
之后交换策略会进行对磁盘内容进行对应修改

补充：
1. **数据读取到Buffer Pool**：修改数据时，如果数据不在内存中，先从磁盘读取到Buffer Pool缓冲池。
2. **记录Redo Log**：在Buffer Pool中修改数据后，立即将修改操作记录到Redo Log（重做日志），采用WAL机制。
3. **记录Binlog**：同时将SQL语句记录到Binlog（二进制日志），用于主从复制和数据恢复。
4. **标记脏页**：Buffer Pool中被修改的数据页被标记为"脏页"。
5. **异步刷盘**：后台线程根据检查点、LRU等策略将脏页异步刷新到磁盘，完成真正的数据落盘。
关键：采用WAL（Write-Ahead Logging）机制，先写日志再写数据，保证数据的持久性和一致性。

[日志详解](#mysql各个日志写入时间)

### 介绍索引的机制
索引通过对特定的字段进行排序，加速对于特定条件的查询加速，相当于是书的目录；
需要额外的占用内存空间

补充：
1. **数据结构**：MySQL的InnoDB引擎主要使用B+树作为索引结构，叶子节点存储数据或指向数据的指针。
2. **工作原理**：索引通过对特定字段进行排序和组织，建立一个有序的数据结构，可以快速定位到目标数据。
3. **查询过程**：执行查询时，MySQL通过索引快速定位满足条件的数据，避免全表扫描。
4. **代价**：索引需要额外存储空间，在数据插入、更新、删除时需要维护索引结构，有一定性能开销。
5. **类型**：包括主键索引、唯一索引、普通索引、复合索引等。

### 什么时候用索引，什么时候不用索引？
范围查询，条件查询，
频繁的插入，破坏索引的结构；字段区分度不大的时候，无法有效提升效率；全表查询；

补充：
**适合用索引的场景：**
- WHERE条件查询、ORDER BY排序、GROUP BY分组
- 范围查询（BETWEEN、>、<）
- 连接查询（JOIN）的关联字段
- 字段区分度高（不同值较多）

**不适合用索引的场景：**
- 频繁插入、更新、删除的表（维护索引开销大）
- 字段区分度低（如性别、状态等）
- 数据量很小的表
- 全表查询场景

### 什么时候回表？
索引没有覆盖全部的字段，查询后还有去数据表中获得完整数据

补充：
**回表发生的情况：**
- 使用非聚簇索引（二级索引）查询，但SELECT的字段不全在索引中
- 例如：索引字段为name，但查询SELECT * FROM table WHERE name='张三'
- 需要通过索引获得主键，再根据主键到聚簇索引中获取完整行数据

**避免回表的方法：**
- 使用覆盖索引（查询字段都在索引中）
- 只查询需要的字段，避免SELECT *

### 介绍事务
事务具有原子性，要么全部成功，要么全部失败；
mysql支持事务，事务有可能造成死锁，要避免长事务；

补充：
**事务的ACID特性：**
- **原子性（Atomicity）**：事务中的所有操作要么全部成功，要么全部失败
- **一致性（Consistency）**：事务执行前后，数据库从一个一致性状态转换到另一个一致性状态
- **隔离性（Isolation）**：并发执行的事务之间相互隔离，不能相互干扰
- **持久性（Durability）**：事务一旦提交，对数据库的改变就是永久性的

**隔离级别：**
- READ UNCOMMITTED（读未提交）
- READ COMMITTED（读已提交）
- REPEATABLE READ（可重复读，MySQL默认）
- SERIALIZABLE（串行化）

**注意事项：**
- 避免长事务，会占用锁资源
- 合理设计事务边界
- 注意死锁问题

### redolog和binlog的区别
binlog是二进制日志，记录实际执行的命令，
redolog记录实际的修改，比如某一行的某个位置修改了什么；
binlog处于是mysqlserver层；
redolog要先于binlog写入，先标记为prepare状态，直到binlog确认，最后commit

补充：
**主要区别：**
1. **层级**：Redo Log属于InnoDB存储引擎层，Binlog属于MySQL Server层
2. **内容**：Redo Log记录物理变化（数据页的具体修改），Binlog记录逻辑变化（SQL语句）
3. **用途**：Redo Log用于崩溃恢复，Binlog用于主从复制和数据备份
4. **写入方式**：Redo Log是循环写入，Binlog是追加写入
5. **事务性**：Redo Log在事务进行中写入，Binlog在事务提交时写入

**两阶段提交：**
为保证一致性，采用两阶段提交：先写Redo Log（prepare状态）→写Binlog→提交Redo Log（commit状态）

### 没有binlog或者redolog会发生什么？
redolog可以避免断电等突发情况的恢复；
bilog用于备份和同步操作，

补充：
**没有Redo Log的后果：**
- 数据库崩溃后无法恢复未提交到磁盘的数据
- 失去崩溃恢复能力，可能导致数据丢失
- 无法保证事务的持久性

**没有Binlog的后果：**
- 无法进行主从复制
- 无法进行基于时间点的数据恢复（PITR - Point-in-Time Recovery）：备份+Binlog的组合可以让你恢复到备份之后的任意历史时间点
- 失去数据备份和同步能力
- 无法进行增量备份：增量备份依赖Binlog记录的变更数据，只备份自上次备份以来的数据变化，大大减少备份时间和存储空间

### mysql什么情况下存在主从延迟问题？
网络波动
binlog积压

补充：
**主从延迟的主要原因：**
1. **网络问题**：网络延迟、带宽不足、网络抖动导致Binlog传输缓慢
2. **Binlog积压**：主库写入压力大，从库来不及消费Binlog，造成积压
3. **从库性能差**：从库硬件配置低，CPU、内存、磁盘IO不足
4. **大事务**：长时间运行的大事务会阻塞后续事务的复制 ？？
5. **锁竞争**：从库上的查询操作与复制线程产生锁冲突
6. **单线程复制**：MySQL 5.6之前只有单线程复制，效率较低 ？？

**解决方案：**
- 升级到支持并行复制的MySQL版本（5.7+）
- 优化网络环境，增加带宽
- 提升从库硬件配置
- 避免长事务，合理设计事务大小
- 读写分离时避免在从库上执行复杂查询

### c++和golang的区别
语法复杂
GC
包管理
库更多

补充：
**主要区别：**
1. **语法复杂度**：C++语法复杂，有指针、模板、多重继承等；Go语法简洁，设计哲学是"少即是多"
2. **内存管理**：C++需要手动管理内存（new/delete）；Go有自动垃圾回收（GC），无需手动释放内存
3. **编译速度**：C++编译慢，特别是大项目；Go编译速度极快，支持快速迭代开发
4. **并发模型**：C++需要使用pthread等库；Go内置goroutine和channel，并发编程更简单
5. **包管理**：C++包管理复杂，依赖管理困难；Go有内置的go mod，包管理统一简洁
6. **生态系统**：C++历史悠久，库更多更成熟；Go相对年轻，但云原生生态丰富
7. **性能**：C++性能更高，更接近底层；Go性能也不错，但有GC开销
8. **应用场景**：C++适合系统编程、游戏开发；Go适合后端服务、微服务、云原生应用

**总结**：Go更适合快速开发高并发的后端服务，C++更适合对性能要求极高的系统级开发。

## 算法
最长连续子数组



<h1 id="mysql各个日志写入时间">mysql各个日志写入时间</h1>

| 阶段                 | **Undo Log**                                                                                              | **Redo Log**                                                                              | **Binlog**                                                              |
| ------------------ | --------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| **执行期（DML 正在修改行）** | ✔ **先写**：在真正改 Buffer Pool 里的数据页之前，先把旧版本/回滚操作写入 **undo log buffer** 并拷贝进对应的 *Undo Page*（这页也在 Buffer Pool）。 | ✔ **同时写**：对页的物理改动立刻生成 redo 记录，追加到 **redo log buffer**（Write-Ahead Logging）。               | ✔ 由 Server 层把本条语句/行事件写入 **binlog cache**（内存），并未落盘。                      |
| **提交阶段 (COMMIT)**  | 通常 **无需额外动作**：Undo 已在执行期写好，是否保留由 purge 线程稍后决定。                                                            | **刷盘/标记**：<br>1. 把本事务区间从 redo log buffer 刷到 redo 文件；<br>2. 事务完成后再追加一条 *commit 标记*（两阶段提交）。 | **刷盘**：将 binlog cache 一次性写到 `mysql-bin.*` 并（按 `sync_binlog` 设置）`fsync`。 |
| **作用**             | 回滚 + MVCC                                                                                                 | 崩溃恢复                                                                                      | 复制 / PITR                                                               |

### 关键点

1. **Undo Log 写在最前面**

   * 只有保证“能回滚”，才能放心修改数据页。

2. **Redo Log 不是只在提交时才写**

   * 每次页面修改就产生 redo 记录，**即时写入 redo log buffer**；提交时只是把对应区间“刷盘+打 commit 标记”。

3. **Binlog 在执行期就生成，但只在提交时落盘**

   * 每个事务在执行期把产生的 binlog event 写入 线程私有的 Binlog Cache（若触发大小阈值会溢写到临时文件）。
   * COMMIT 阶段，该线程把自己的 Binlog Cache 拷贝到 全局 Binlog Buffer（write cache）。
   * 组提交( group commit ) 的首个线程负责把 Binlog Buffer 里的连续区块写入 mysql-bin.xxxxxx 文件(此时在内核page cache中)，并按 sync_binlog 策略决定是否立刻 fsync()。
   * 完成后，它再给每个事务设置 binlog_done 标记，唤醒等待队列中的同行事务，整个组一起进入“写 redo commit flag”阶段，从而保证 两阶段提交一致性（“先刷 redo → 写入/刷 binlog → 再写 redo commit”）。

> 所以顺序大致是：
> **Undo ➜ Redo（缓冲）➜ 修改 Buffer Pool ➜ … ➜ COMMIT ➜ 刷 Redo ➜ 刷 Binlog ➜ Redo commit 标记**
> — 其中只有 Undo 页会出现在 Buffer Pool，Redo/Binlog 文件页永远不进 Buffer Pool。



注意：

Undo Log 的任何持久状态变更都会触发 redo 记录；

Redo 不关注“这是不是回滚日志”，它只关心“页有没有被修改”。因此数据页、索引页、系统页、Undo 页、甚至数据字典页的改动都会产出 redo。

这样崩溃恢复时，InnoDB 先用 redo 把所有脏页（包括 Undo 页）回放到最新 LSN，再利用 Undo 链决定哪些事务需要回滚，保证一致性。