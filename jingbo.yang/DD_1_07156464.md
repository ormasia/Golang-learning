# 滴滴一面(社招)
自我介绍，在做项目的时候作为什么角色？

## nginx访问日志中，统计ip的个数命令是什么？
```bash
cat access.log | awk '{print $1}' | sort -u | wc -l  

awk '{print $1}'：提取日志中的第一个字段（通常是客户端 IP）。
sort -u：对 IP 去重（排序后删除重复项）。
wc -l：统计去重后的 IP 行数，即独立 IP 总数。
```
grep：按行筛选符合条件的文本（如匹配特定 IP）。
awk/cut：提取特定字段（如日志中的 IP 字段）。
sort：对文本排序（为去重或分组做准备）。
uniq：统计重复行的次数（需先排序）。
wc：统计行数、字数等。

## 如何做服务治理？有哪些方案？
服务治理是指对微服务架构中的服务进行管理和控制，以确保服务的可靠性、可用性和性能。常见的服务治理方案包括：

## 什么时候扩容？什么时候限流？
- **扩容**：当服务的负载超过预设的阈值时（如CPU使用率、内存使用率、请求响应时间等），或者在高峰期（如双十一、618等大促）前进行预热和扩容。
- **限流**：当服务的请求量超过预设的限流阈值时，或者在系统负载过高时进行限流，以保护系统不被过载。常见的限流策略包括令牌桶、漏桶等。

## 服务有大量的timewait的时候，如何去排查？
``` bash
ss -s
netstat -an | grep TIME_WAIT | wc -l
```
| 参数 | 含义 | 示例 |
|------|------|------|
| `-a` | 显示所有连接和监听端口 | `netstat -a` |
| `-n` | 数字形式显示地址和端口 | `netstat -n` |
| `-t` | 仅显示 TCP 连接 | `netstat -atn` |
| `-u` | 仅显示 UDP 连接 | `netstat -aun` |
| `-p` | 显示进程信息（需 root 权限） | `netstat -atnp` |
| `-l` | 仅显示监听中的端口 | `netstat -ln` |
| `-r` | 显示路由表 | `netstat -r` |

| 排查步骤 | 具体操作 | 目的 |
|------|------|------|
| **确认TIME_WAIT数量** | `netstat -an | grep TIME_WAIT | wc -l`（统计总数）；<br>`netstat -an | grep TIME_WAIT | awk '{print $4}' | cut -d: -f2 | sort | uniq -c | sort -nr`（按本地端口分布） | 明确问题规模及热点端口 |
| **理解TIME_WAIT作用** | 了解TCP四次挥手机制：主动关闭方进入TIME_WAIT，持续2MSL（通常60秒），用于确保ACK送达和避免延迟包干扰 | 明确状态存在的必要性，为后续优化提供理论基础 |
| **排查高TIME_WAIT原因** | **服务端主动关闭连接**：<br>`netstat -anp | grep TIME_WAIT | awk '{print $4, $7}'`（查看本地端口，判断是否为服务端口）；<br>**短连接设计不合理**：检查应用代码是否使用连接池，是否频繁创建新连接；<br>**高并发连接耗尽**：`sysctl net.ipv4.ip_local_port_range`（查看端口范围）；`netstat -an | grep ESTABLISHED | wc -l`（查看已建立连接数） | 定位问题源头，区分是服务端行为、连接设计问题还是并发压力导致 |
| **临时缓解措施（系统参数调优）** | `sysctl -w net.ipv4.tcp_fin_timeout=30`（缩短超时时间）；<br>`sysctl -w net.ipv4.tcp_tw_reuse=1`（允许重用TIME_WAIT端口）；<br>`sysctl -w net.ipv4.tcp_tw_recycle=1`（启用快速回收，内核3.7+有效，注意NAT环境问题）；<br>`sysctl -w net.ipv4.ip_local_port_range="10000 65535"`（扩大端口范围）；<br>配置永久生效：`echo "参数" >> /etc/sysctl.conf` 后执行 `sysctl -p` | 快速降低TIME_WAIT数量，缓解服务压力 |
| **长期解决方案（应用层优化）** | 使用长连接：HTTP/1.1启用`Connection: keep-alive`，HTTP/2默认多路复用；<br>数据库/微服务调用使用连接池；<br>优化应用逻辑，减少不必要的连接创建和关闭 | 从根本上减少连接频繁建立关闭的情况 |
| **架构优化** | 负载均衡：通过Nginx、HAProxy等分散连接压力；<br>水平扩展服务实例，减少单个节点连接数 | 分散压力，避免单点连接过载 |
| **监控和预警** | **实时监控**：`watch "netstat -an | grep TIME_WAIT | wc -l"`（持续监控数量）；<br>`netstat -an | grep TIME_WAIT | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr`（查看IP分布）；<br>**预警指标**：当TIME_WAIT数量超过可用端口80%时警报；使用Prometheus+Grafana或ELK监控 | 及时发现问题并预警，避免影响服务可用性 |
| **总结** | 临时措施：调整系统参数；<br>根本解决：应用层改用长连接，优化连接管理；<br>架构优化：水平扩展服务 | 提供完整的问题处理路径，从临时缓解到长期解决 |

## mysql三种日志的顺序

执行变更：先写 undo log（记录旧数据），再修改 Buffer Pool，同时记录 redo log。
提交事务：按顺序刷 redo log 到磁盘 → 刷 binlog 到磁盘 → 标记事务提交。
异步刷盘：脏页在后台异步刷新到磁盘。
**redolog一定是早于刷盘的**

## 内存持续升高原因的排查思路

## 表中有大量数据，请求查询的时候比较慢，如何排查？如何调优？

## 是否了解cap理论，redis中选择了哪些？还用到了其他缓存中间件吗？


# 日常遇到的问题
## 协程怎么关闭？
协程的关闭可以通过以下几种方式实现：1. **使用 `context` 包**：通过创建一个带有取消功能的 `context`，在需要关闭协程时调用 `cancel()` 函数。协程可以通过监听 `context.Done()` 来判断何时退出。  
1. **使用通道**：创建一个 `chan struct{}` 类型的通道，协程可以通过接收这个通道来判断是否需要退出。当主协程发送一个信号到这个通道时，其他协程可以接收到这个信号并执行清理工作后退出。  
2. **使用标志变量**：在协程中使用一个共享的布尔变量来表示是否需要   退出。协程可以定期检查这个变量的值，如果为 `true` 则退出(return)。  
3. **使用 `sync.WaitGroup`**：在主协程中使用 `sync.WaitGroup` 来等待所有子协程完成。在子协程中调用 `wg.Done()` 来表示完成，主协程可以通过 `wg.Wait()` 等待所有子协程退出。


## interface 传进去一个nil 会怎么样？

``` go
type eface struct {
	_type *_type
	data  unsafe.Pointer
}
```
        eface结构体表示不含 method 的 interface 结构，有一个字段_type *_type表示类型，有一个字段data unsafe.Pointer指向了这个interface代表的具体数据

因为`interface{}` 类型的变量存储了两个部分：一个是类型信息，一个是具体的值。  
当将一个 `nil` 的 `[]int` 切片赋给一个` interface{}` 类型的变量时，虽然切片的值是 `nil`，但它的类型信息仍然存在。因此，这个` interface{}` 类型的变量本身并不会是 `nil`。  
**要判断一个 `interface{}` 是否真正是 `nil`，它的类型信息部分和值部分都必须是 `nil`。**
