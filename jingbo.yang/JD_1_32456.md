![alt text](pic/image.png)
# 京东零售后端一面
自我介绍，有没有用过cpp，java 

## 有没有设计过多线程高并发的开发？
学习网络编程中，实现过一个多线程HTTP服务器，采用reactor网络模型，利用池化技术(线程池，数据库连接池)优化并发，利用epoll+非阻塞socket，模拟异步网络io；

**不足之处与建议**：
- **具体性**：可以更具体地说明“池化技术”如何优化并发（例如，减少资源创建和销毁的开销，复用已有资源）。
- **epoll+非阻塞socket**：这本身就是一种实现高性能异步I/O的方式，而不是“模拟”。可以说“利用epoll实现I/O多路复用，配合非阻塞socket处理大量并发连接”。
- **成果或挑战**：如果可能，可以简要提及在该项目中遇到的挑战以及如何解决的，或者达成的性能指标，更能体现经验。

## 进程 线程 协程
最小分配资源单位
最小调度单元
协程是用户态轻量级线程，对操作系统透明，占用资源小，大约2kb，可以创建上万goroutine

**补充完善**：
- **进程**：最小资源分配单位，拥有独立的虚拟地址空间，进程间通信需要特殊机制(管道、共享内存等)
- **线程**：最小调度单位，共享进程的地址空间，但有独立的栈和寄存器
- **协程**：用户态轻量级线程，由语言运行时调度，切换开销小，适合I/O密集型任务

## 什么时候使用多线程什么时候使用多协程？
io操作频繁适合多协程
计算密集型适合多线程

**补充完善**：
- **I/O密集型与协程**：协程切换成本远低于线程，当任务需要频繁等待I/O（网络请求、文件读写）时，协程能让出CPU给其他协程执行，从而提高CPU利用率和并发度。Go的GMP调度模型特别适合这种情况。
- **计算密集型与线程**：计算密集型任务需要长时间占用CPU进行计算。多线程能真正利用多核CPU并行计算。如果用协程，虽然可以创建很多，但如果只有一个或少数几个P（处理器），实际并行度受限于P的数量。对于纯计算任务，多线程（或多进程）更能发挥多核优势。
- **Go的实践**：在Go中，通常优先使用协程处理并发。对于计算密集型任务，可以通过调整`GOMAXPROCS`配合协程来利用多核，或者在必要时结合cgo调用C库的多线程实现。

## 多个协程在单个线程还是多个线程实现？M:1?M:N,详细讲一下？
我描述一下GMP调度，单个线程运行一组协程，并发执行
出现线程阻塞会将P绑定到其他的M中，
所以，M:1只能并发执行，M:N可以实现对于协程的调度

**补充完善**：
- **M:1模型**：多个协程映射到一个内核线程，优点是切换快，缺点是无法利用多核，一个阻塞全阻塞
- **1:1模型**：一个协程对应一个内核线程，可以利用多核，但创建开销大
- **M:N模型**：Go采用的模型，M个协程映射到N个内核线程，通过GMP调度器实现：
  - G: Goroutine协程
  - M: Machine内核线程  
  - P: Processor逻辑处理器，管理G的队列
- 优势：既能利用多核，又保持了协程的轻量级特性

## 调度的时候又有协程又有线程是怎么调度的？
？？不清楚是在问什么？？
M需要P才能执行

**补充完善**：
面试官可能想问的是**多级调度**问题：
1. **操作系统调度**：内核负责调度线程(M)到CPU核心上执行
2. **Go运行时调度**：Go调度器负责将协程(G)调度到线程(M)上执行
3. **调度流程**：
   - OS调度器选择线程M运行
   - Go调度器从P的队列中选择G在M上执行
   - 当G阻塞时，M可能会handoff给其他M继续执行P队列中的其他G
4. **两级调度的好处**：用户态调度减少内核态切换开销，提高并发性能

## 讲一下GC
开启STW
栈，全局变量作为根节点
递归进行三色标记
GC期间所有

**补充完善**（回答不完整）：
**Go的三色标记GC算法**：
1. **标记准备**：STW，扫描栈、全局变量等GC Root
2. **并发标记**：恢复程序执行，与用户程序并发进行三色标记
   - 白色：未访问的对象，最终会被回收
   - 灰色：已访问但其引用对象未完全标记的对象  
   - 黑色：已访问且其引用对象都已标记的对象
3. **重新扫描**：短暂STW，处理标记过程中的变化
4. **清扫回收**：并发清理白色对象

**写屏障技术**：解决标记过程中指针修改导致的对象遗漏问题

## 怎么会发生oom？panic&recover？
死循环，一直创建协程，控制并发，大量请求进入，没有使用池化？
出现panic通过recover捕获，避免将一场传递到main函数运行所在协程中，导致程序崩溃；

**不足之处与建议**：
**OOM (Out Of Memory) 原因**：
-   **协程泄漏**：创建了大量协程但没有正确退出，每个协程占用的少量栈空间累积起来导致OOM。
-   **内存泄漏**：
    -   全局变量持有大量数据且持续增长（如map未清理）。
    -   长生命周期的对象（如缓存）无限制增长。
    -   slice使用不当，导致底层数组无法释放（例如，大切片截取小部分后，原大切片仍被引用）。
    -   cgo调用外部库，外部库发生内存泄漏。
-   **大量数据处理**：一次性加载过多数据到内存中处理。
-   **不合理的并发控制**：瞬间并发过高，导致资源（如内存）请求激增。
-   你的回答中“死循环，一直创建协程”是正确的。“控制并发”是解决方案。“大量请求进入，没有使用池化？”可以更具体，比如连接池耗尽后不断创建新连接，或请求处理中创建了大量临时对象。

**panic & recover**：
-   你的解释基本正确。可以补充：
    -   `recover()`必须在`defer`函数中直接调用才有效。
    -   `recover()`捕获的是当前goroutine的panic，无法捕获其他goroutine的panic。
    -   捕获panic后，应记录错误信息，并根据业务场景决定是优雅关闭、返回错误还是尝试恢复。
    -   滥用`panic`和`recover`进行正常的错误处理流程是不推荐的，应优先使用Go的错误返回值机制。

## 有没有做过MySQL的优化？分库分表？
配置优化？

**不足之处与建议**：
-   回答过于简单，像是在反问。应主动列举你知道或做过的优化点。
-   **常见的MySQL优化方向**：
    1.  **SQL语句优化**：
        *   使用`EXPLAIN`分析查询计划，确保索引用对。
        *   避免`SELECT *`，只查询需要的列。
        *   优化`JOIN`查询，确保连接条件有索引。
        *   避免在`WHERE`子句中对索引列使用函数或运算。
        *   使用批量操作（`INSERT INTO ... VALUES (...), (...), ...`）。
    2.  **索引优化**：
        *   为经常用于查询条件、排序、分组的列创建索引。
        *   使用覆盖索引避免回表。
        *   注意索引选择性，避免过多低效索引。
        *   定期检查和维护索引（如删除未使用索引）。
    3.  **数据库结构设计优化**：
        *   选择合适的字段类型和长度。
        *   遵循范式设计，但也可能为了性能适度反范式。
    4.  **服务器配置优化**：
        *   调整`innodb_buffer_pool_size`（核心配置）。
        *   调整连接数`max_connections`。
        *   日志相关配置（`binlog_format`, `sync_binlog`, `innodb_flush_log_at_trx_commit`）。
        *   查询缓存（MySQL 8.0已移除，早期版本可考虑）。
    5.  **架构层面优化**：
        *   **读写分离**：主库写，从库读，分摊压力。
        *   **缓存**：使用Redis等缓存热点数据。
        *   **分库分表**：当单表数据量过大或并发过高时考虑。
            *   **垂直分库/分表**：按业务模块或字段拆分。
            *   **水平分库/分表**：按数据范围或哈希等规则将数据分散到多个库/表。
-   面试官提到“分库分表”，你应该就这个点展开，即使没有实际做过，也可以谈谈你的理解，比如什么时候需要分库分表，有哪些常见策略和带来的问题（如分布式事务、跨库查询）。

## 一个查询很慢怎么知道慢在哪里？
开启慢查询日志，定位慢查询，explain 查看sql走了什么索引，有哪些锁；

## 讲一下行锁的类型
记录锁recor-lock
间隙锁
范围锁

**补充完善**：
**InnoDB行锁类型**：
1. **记录锁(Record Lock)**：锁定索引记录，防止其他事务修改或删除
2. **间隙锁(Gap Lock)**：锁定索引记录之间的间隙，防止插入新记录，解决幻读
3. **临键锁(Next-Key Lock)**：记录锁+间隙锁，锁定记录及其前面的间隙
4. **插入意向锁(Insert Intention Lock)**：插入前获取的特殊间隙锁，多个事务可同时持有

**触发条件**：
- RR隔离级别下，范围查询会加临键锁
- 唯一索引等值查询加记录锁
- 非唯一索引查询加临键锁

## MySQL死锁产生的原因
死锁产生条件
不可抢夺，
持有等待，

**补充完善**（回答不完整）：
**死锁产生的四个必要条件**：
1. **互斥条件**：资源不能被多个事务同时占用
2. **持有等待**：事务持有资源的同时等待其他资源
3. **不可抢夺**：已分配的资源不能被强制回收
4. **循环等待**：多个事务形成环形等待链

**MySQL死锁的常见场景**：
- 两个事务以不同顺序获取相同的锁
- 事务1锁定A等待B，事务2锁定B等待A
- 范围锁和插入操作冲突

**死锁检测与处理**：
- InnoDB有死锁检测机制，会选择代价小的事务进行回滚
- 可通过`SHOW ENGINE INNODB STATUS`查看死锁信息

## cgo是什么？有什么作用？

`cgo` 是 Go 语言提供的一个工具，它允许 Go 程序调用 C 语言编写的代码。

**cgo 的主要作用：**

1.  **复用现有的 C 库：**
    *   C 语言拥有大量成熟、高效的库（例如，图形库、科学计算库、特定的硬件驱动接口等）。通过 `cgo`，Go 程序可以直接利用这些现有的 C 代码，而无需用 Go 重写。

2.  **访问底层系统功能：**
    *   某些操作系统底层的功能可能没有直接的 Go API 封装，但通常会有 C 语言的接口。`cgo` 使得 Go 程序能够调用这些底层的 C API。

3.  **性能敏感部分：**
    *   在极少数情况下，对于某些性能极其敏感的计算密集型任务，如果已有的 C 实现非常高效，或者开发者对 C 的底层优化有更深经验，可能会选择使用 `cgo` 调用 C 代码。但需要注意的是，`cgo` 调用本身也有开销。

4.  **与其他语言的互操作：**
    *   虽然主要是 Go 与 C 的桥梁，但因为很多其他语言（如 C++, Python 等）也能与 C 互操作，`cgo` 间接也为 Go 与这些语言的交互提供了一种可能。

**cgo 的工作方式简述：**

*   开发者在 Go 源文件中使用特殊的 `import "C"` 语句，并在其上方的注释块中编写 C 代码或包含 C 头文件。
*   `cgo` 工具会处理这些 Go 文件，生成必要的 Go 和 C 的“胶水代码”（glue code），使得 Go 和 C 之间可以相互调用函数、传递数据。
*   编译时，Go 编译器和 C 编译器会协同工作，将 Go 代码、C 代码以及胶水代码编译链接成最终的可执行文件。

**使用 cgo 的一些注意事项和权衡：**

*   **构建复杂性增加：** 引入 `cgo` 会使得构建过程依赖于 C 编译器（如 GCC 或 Clang）。
*   **调用开销：** Go 调用 C 函数（反之亦然）存在一定的性能开销，因为需要进行栈切换、数据类型转换等。
*   **内存管理：** Go 有自己的垃圾回收机制，而 C 需要手动管理内存。在使用 `cgo` 时，需要特别注意跨语言边界的内存管理，避免内存泄漏或野指针。
*   **类型转换：** 需要在 Go 类型和 C 类型之间进行显式转换。
*   **可移植性：** 如果 C 代码是平台相关的，那么使用了 `cgo` 的 Go 程序的可移植性可能会受到影响。
*   **调试难度：** 跨语言调试可能会更复杂。

## 500并发请求
场景：假设有一个接口需要对外提供服务，该接口的处理逻辑是查询数据库并将结果写入缓存。为了应对高并发请求，采用了以下措施：
- 数据库查询使用了连接池技术，限制最大连接数为100。
- 查询结果缓存到Redis，设置了合理的过期时间。
- 接口层面使用了限流器，限制每秒最多处理1000个请求。
- 对于突发的高并发请求，采用了熔断机制，暂时拒绝服务，返回503状态码。

**总结**：
在500并发请求访问DB并写缓存的场景下，**加锁（尤其是分布式锁或利用`singleflight`）是防止缓存击穿导致DB过载的关键手段**。同时，可以结合缓存预热、合理的过期策略、限流熔断等多种优化措施，构建更健壮的缓存系统。

可以进一步细化策略：对于请求相同资源的情况（例如大量请求同一个热点key），`singleflight` 是非常有效的；对于请求不同资源但总体并发量过大的情况，应考虑限流或熔断机制来保护下游服务。




