# 腾讯csig暑期实习 一二三面

## redis和mysql如何保证一致性

## redis和mysql如何保证一致性？

## 讲一下DDD的概念，聚合根，实体等具体是指什么？

## 慢查询优化是怎么做的？
## 什么是聚簇索引？
## 联合索引在什么情况下会失效？
## redis 持久化是怎么做的？
aof rdb aof+rdb混合模式
## 跳表是什么？
将链表升级为多层索引结构，提升查找效率。相当于建立了多级索引。

## 缓存击穿，缓存穿透，缓存雪崩的概念和解决方法？
缓存击穿：缓存中不存在某个热点数据，导致大量请求直接打到数据库上。解决方法：使用互斥锁或布隆过滤器。
缓存穿透：请求的数据在缓存和数据库中都不存在，导致每次请求都打到数据库上。解决方法：使用布隆过滤器或缓存空对象。
缓存雪崩：缓存中大量数据同时过期，导致大量请求直接打到数据库上。解决方法：设置不同的过期时间，使用预热机制。
## tcp三次握手和四次挥手的过程是什么样子？

### **一、三次握手（建立连接）的状态转换**  
三次握手的目标是让客户端和服务端确认彼此的发送和接收能力，最终建立双向通信的连接。双方状态变化如下：

| 阶段 | 客户端状态       | 服务端状态       | 动作描述                                                                 |
|------|------------------|------------------|--------------------------------------------------------------------------|
| 初始 | `CLOSED`         | `LISTEN`         | 服务端先启动，进入监听状态（`LISTEN`），等待客户端连接；客户端初始为关闭状态。 |
| 1st  | `SYN_SENT`       | `LISTEN` → `SYN_RCVD` | 客户端发送 `SYN` 报文（请求连接），进入 `SYN_SENT` 状态；服务端收到 `SYN` 后，进入 `SYN_RCVD` 状态，并回复 `SYN+ACK` 报文。 |
| 2nd  | `SYN_SENT` → `ESTABLISHED` | `SYN_RCVD`       | 客户端收到 `SYN+ACK` 后，进入 `ESTABLISHED` 状态，并发送 `ACK` 报文（确认连接）。 |
| 3rd  | `ESTABLISHED`    | `SYN_RCVD` → `ESTABLISHED` | 服务端收到 `ACK` 后，进入 `ESTABLISHED` 状态，双方连接建立，可开始数据传输。 |


#### 关键状态说明：  
- **`LISTEN`**：服务端专用状态，表示已准备好接收连接请求（如 `bind()` 和 `listen()` 后进入此状态）。  
- **`SYN_SENT`**：客户端发送 `SYN` 后进入，等待服务端的 `SYN+ACK` 响应。  
- **`SYN_RCVD`**：服务端收到 `SYN` 后进入，等待客户端的 `ACK` 确认。  
- **`ESTABLISHED`**：连接已建立，双方可正常发送和接收数据（数据传输阶段的主要状态）。  


### **二、四次挥手（断开连接）的状态转换**  
TCP 是全双工通信，断开连接时需要双方分别确认“不再发送数据”，因此需要四次交互。假设客户端先发起断开请求（实际双方均可主动发起）：

| 阶段 | 客户端状态         | 服务端状态         | 动作描述                                                                 |
|------|--------------------|--------------------|--------------------------------------------------------------------------|
| 初始 | `ESTABLISHED`      | `ESTABLISHED`      | 连接处于数据传输状态，双方均为 `ESTABLISHED`。                             |
| 1st  | `ESTABLISHED` → `FIN_WAIT_1` | `ESTABLISHED`      | 客户端主动关闭连接，发送 `FIN` 报文（表示不再发送数据），进入 `FIN_WAIT_1` 状态，等待服务端的 `ACK`。 |
| 2nd  | `FIN_WAIT_1` → `FIN_WAIT_2` | `ESTABLISHED` → `CLOSE_WAIT` | 服务端收到 `FIN` 后，先回复 `ACK` 报文（确认收到关闭请求），进入 `CLOSE_WAIT` 状态（此时服务端仍可向客户端发送数据）；客户端收到 `ACK` 后，进入 `FIN_WAIT_2` 状态，等待服务端的 `FIN`。 |
| 3rd  | `FIN_WAIT_2`       | `CLOSE_WAIT` → `LAST_ACK` | 服务端完成所有数据发送后，发送 `FIN` 报文（表示自己也不再发送数据），进入 `LAST_ACK` 状态，等待客户端的 `ACK`。 |
| 4th  | `FIN_WAIT_2` → `TIME_WAIT` | `LAST_ACK` → `CLOSED` | 客户端收到服务端的 `FIN` 后，回复 `ACK` 报文，进入 `TIME_WAIT` 状态；服务端收到 `ACK` 后，立即进入 `CLOSED` 状态（断开完成）。 |
| 最终 | `TIME_WAIT` → `CLOSED` | `CLOSED`           | 客户端在 `TIME_WAIT` 状态等待 **2MSL（报文最大生存时间，通常为1-4分钟）** 后，确保服务端已收到 `ACK`，最终进入 `CLOSED` 状态。 |


#### 关键状态说明：  
- **`FIN_WAIT_1`**：客户端发送 `FIN` 后，等待服务端 `ACK` 的状态。  
- **`FIN_WAIT_2`**：客户端收到服务端 `ACK` 后，等待服务端 `FIN` 的状态（此时客户端已无法发送数据，但可接收服务端数据）。  
- **`CLOSE_WAIT`**：服务端收到客户端 `FIN` 后，等待自身数据发送完成的状态（需应用层主动调用 `close()` 触发后续 `FIN` 发送）。  
- **`LAST_ACK`**：服务端发送 `FIN` 后，等待客户端 `ACK` 的状态。  
- **`TIME_WAIT`**：客户端发送最后一个 `ACK` 后进入，等待 2MSL 时间，目的是：<br>  1. 确保服务端能收到最后的 `ACK`（若 `ACK` 丢失，服务端会重发 `FIN`，客户端可在 `TIME_WAIT` 内重发 `ACK`）；<br>  2. 避免旧连接的残留报文干扰新连接（2MSL 后，旧报文会被网络丢弃）。  


### **总结**  
- **三次握手**通过 `SYN_SENT`、`SYN_RCVD` 等状态确保双方收发能力正常，最终进入 `ESTABLISHED` 状态。  
- **四次挥手**通过 `FIN_WAIT`、`CLOSE_WAIT`、`TIME_WAIT` 等状态处理全双工连接的有序关闭，尤其是 `TIME_WAIT` 状态是保证 TCP 可靠性的关键设计。  

## 拥塞窗口和接收窗口的区别？
拥塞窗口（cwnd）：TCP协议中用于控制发送方发送数据的速率，防止网络拥塞。它是根据网络状况动态调整的。  
接收窗口（rwnd）：TCP协议中用于控制接收方能够接收的数据量。它是由接收方根据自身缓冲区大小决定的。  
这两者共同决定了tcp连接的滑动窗口大小；

### 拥塞窗口在什么情况下大小会变成当前大小的一半？？
以下是TCP核心概念及特点的总结表格，涵盖拥塞控制、窗口机制等关键内容：

| **概念**         | **全称/含义**                          | **核心特点**                                                                                                                                 | **作用场景**                                                                 |
|------------------|---------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|
| **TCP**          | Transmission Control Protocol         | 面向连接、可靠传输、字节流服务、全双工通信；通过序号、确认、重传等机制保证可靠性。                                                             | 需可靠数据传输的场景（如HTTP、FTP、邮件等）。                               |
| **拥塞窗口（cwnd）** | Congestion Window                     | 发送方根据网络拥塞状况动态调整的窗口大小，控制发送速率；大小由拥塞控制算法决定。                                                               | 避免网络因发送数据过多而拥塞。                                               |
| **接收窗口（rwnd）** | Receive Window                        | 接收方告知发送方的缓冲区剩余容量，是TCP流量控制的核心参数；随接收方处理能力动态变化。                                                         | 防止发送方发送速率超过接收方处理能力（流量控制）。                           |
| **滑动窗口**     | Sliding Window                        | 实际发送窗口大小 = min(cwnd, rwnd)；发送方通过窗口滑动确认已接收数据，未确认数据需重传。                                                       | 实现TCP的流量控制与可靠传输，提高传输效率。                                 |
| **慢启动阈值（ssthresh）** | Slow Start Threshold                  | 拥塞控制中慢启动与拥塞避免阶段的分界值；当cwnd < ssthresh时进入慢启动，≥ssthresh时进入拥塞避免。                                               | 调节拥塞窗口增长方式，平衡带宽利用与拥塞风险。                               |
| **慢启动**       | Slow Start                            | cwnd < ssthresh时，cwnd按指数增长（每轮RTT翻倍）；初始值通常为1-2个MSS。                                                                       | 连接建立初期或超时重传后，快速探测网络可用带宽。                             |
| **拥塞避免**     | Congestion Avoidance                  | cwnd ≥ ssthresh时，cwnd按线性增长（每轮RTT增加1个MSS）。                                                                                       | 接近网络承载上限时，平稳增长发送速率，减少拥塞概率。                         |
| **快重传**       | Fast Retransmit                       | 收到连续3个重复ACK时，立即重传丢失的报文段，无需等待超时。                                                                                     | 快速修复报文丢失，减少重传延迟。                                             |
| **快恢复**       | Fast Recovery                         | 快重传触发后，将ssthresh设为当前cwnd的一半，cwnd设为新ssthresh，随后进入拥塞避免阶段（线性增长）。                                               | 网络未完全拥塞时（仅部分丢包），快速恢复传输速率，避免过度降低发送效率。     |
| **超时重传**     | Timeout Retransmission                | 发送方未在超时时间内收到ACK，判定报文丢失，重传该报文；触发后将ssthresh设为当前cwnd的一半，cwnd重置为初始值（1个MSS），重新进入慢启动。         | 网络严重拥塞（如大量丢包）时，彻底降低发送速率，重新探测网络。               |
| **ACK**          | Acknowledgment                        | 接收方对已接收数据的确认；包含期望接收的下一字节序号，可携带rwnd信息。                                                                         | 确认数据接收状态，触发发送方窗口调整（如cwnd增长、滑动窗口移动）。           |
| **MSS**          | Maximum Segment Size                  | TCP报文段的最大数据部分长度（不含首部）；由通信双方协商确定，通常与链路MTU（最大传输单元）匹配。                                               | 避免IP层分片，提高传输效率。                                                 |

## 算法
- 三数之和
- 原地删除重复元素，最多重复两次，返回新的长度

# 三面

算法：左右括号匹配
## 实习最大的挑战是什么？
开发效率
## 对于CDN业务的了解
CDN（内容分发网络）是通过在全球各地部署边缘节点，将静态资源缓存到离用户更近的服务器上，以减少延迟和提高访问速度。
## TCP和UDP的区别
包头大小：TCP包头20字节，UDP包头8字节。
连接方式：TCP是面向连接的协议，UDP是无连接的协议。
可靠性：TCP提供可靠的数据传输，保证数据的顺序和完整性；UDP不保证数据的可靠性，可能出现丢包、重复或乱序。
使用场景：TCP适用于需要可靠传输的应用（如HTTP、FTP），UDP适用于对实时性要求高但可以容忍丢包的应用（如视频直播、在线游戏）。
## 会议系统用什么协议？
会议系统通常使用UDP协议，因为它具有低延迟和高效率的特点，适合实时音视频传输。对于需要可靠性的部分（如信令），可以使用TCP协议。
## http和https的区别
HTTP（超文本传输协议）是无状态的应用层协议，使用明文传输数据。HTTPS（安全超文本传输协议）在HTTP的基础上增加了SSL/TLS加密层，提供数据加密、身份验证和完整性保护。
## 数字证书的参数
数字证书是一份 带签名的身份证：它把「持有者 DN + 公钥 + 使用限制 + 有效期」这些信息做成不可篡改的结构体，签名者通常是上级 CA。

### 1  什么是“持有者 DN”？

* **DN = Distinguished Name（可分辨名称）**
  它是 X.509 证书里 **Subject** 字段的规范写法，*用一串“**属性=值**”对唯一地标识证书持有者。*
* 常见属性缩写

  | 缩写     | 含义             | 示例                                         |
  | ------ | -------------- | ------------------------------------------ |
  | **CN** | Common Name    | `CN=www.douyin.com`（服务器域名）或 `CN=张三`（个人）    |
  | **O**  | Organization   | `O=Beijing ByteDance Technology Co., Ltd.` |
  | **OU** | Org. Unit      | `OU=Tech Department`                       |
  | **L**  | Locality       | `L=Beijing`                                |
  | **ST** | State/Province | `ST=Beijing`                               |
  | **C**  | Country        | `C=CN`                                     |

> 在服务器证书中，最关键的是 **CN（或 SubjectAltName 扩展里的 DNS 列表）** —— 浏览器要把它与你访问的域名比对，确保“证书归这个站点所有”。

---

### 2  拿到证书后客户端必须做哪些验证？

| 步骤                      | 关键点                                                      | 失败后浏览器如何表现                                 |
| ----------------------- | -------------------------------------------------------- | ------------------------------------------ |
| **a. 构建证书链**            | 把服务器发来的叶子证书 + 中间证书拼到本地信任根（Root CA）。                      | *ERR\_CERT\_AUTHORITY\_INVALID*（证书链不信任）    |
| **b. 签名校验**             | 从根向下逐级用上级公钥验证下级证书的 Signature。                            | *ERR\_CERT\_SIGNATURE\_FAILED*             |
| **c. 有效期检查**            | 当前时间必须落在 `Not Before` \~ `Not After` 区间。                 | *ERR\_CERT\_DATE\_INVALID*                 |
| **d. 主机名匹配**            | 访问域名应匹配 **SubjectAltName** 或 `CN` 通配；`www`≠`api`。        | *ERR\_CERT\_COMMON\_NAME\_INVALID*         |
| **e. 证书用途**             | `KeyUsage` / `ExtendedKeyUsage` 必须含 `serverAuth`(HTTPS)。 | *ERR\_CERT\_INVALID*                       |
| **f. 撤销检查（可选）**         | 通过 OCSP/CRL 确认证书未被吊销。                                    | 新浏览器用 OCSP Stapling、CRLset；失败通常降级继续，或显示警告。 |
| **g. HSTS/HPKP**（若站点启用） | 若站点声明必须用 HTTPS 且证书指纹应匹配 pin，则进一步检查。                      | 浏览器强制拒绝降级到 HTTP；Pin 不符触发红屏。                |

> **客户端（浏览器/SDK）只有在全部校验通过后，TLS 握手才能进入“生成会话密钥、开始加密通信”的阶段**。
> 在用户层面，任何一步失败都会看到“证书不受信任/已过期/域名不匹配”等安全提示。

补充：

        Subject Alternative Name（SAN，OID 2.5.29.17） 是 X.509 v3 证书里最常用的可选扩展之一。  
        其中的 dNSName 项通常被称作“DNS 列表”，用来写出这张服务器证书可合法覆盖的所有域名。浏览器或 TLS 客户端会把你访问的主机名与这里的条目逐一比对，只有匹配成功才认为证书属于目标站点。

---

#### 小结

* **持有者 DN** 就是证书里描述“这张证书属于谁”的 X.500 可分辨名称，最常用部分是 `CN`。
* **证书验证** 不只是看签名，还包括链、日期、域名、用途和撤销状态等多重检查；只有全部合格，浏览器才会把“HTTPS 安全锁”点亮。


不用“实时去找 CA 服务器”做签名校验。**证书链的完整性验证全部在本地完成**：

1. **根证书（Root CA）**

   * 浏览器/操作系统在安装时就内置了一批受信任的根公钥。
   * 校验时，客户端只需拿这些本地根公钥逐级验证下级证书签名即可。

2. **中间证书**

   * 服务器会连同站点证书把中间证书链（或称 *证书链文件*）发送给客户端，客户端本地拼链。
   * 只要链能一直“串”到某个受信任根，就算签名合法，无需联网找 CA。

---

### 什么时候可能“联系” CA？

| 目的          | 机制                              | 说明                                                                  |
| ----------- | ------------------------------- | ------------------------------------------------------------------- |
| **撤销状态检查**  | **OCSP**（在线查询）或 **CRL**（下载吊销列表） | 确认证书是否被吊销。若服务器启用了 **OCSP Stapling**，撤销响应直接随 TLS 握手发来，也无需浏览器再去请求 CA。 |
| **自动更新根证书** | 操作系统／浏览器的更新程序                   | 新根加入或旧根吊销时，系统后台会定期拉取根证书列表，但这不影响每次握手的即时验证。                           |

> **结论：**
>
> * **签名/链验证**：完全本地完成，无需实时访问 CA。
> * **撤销检查**：可能发起 OCSP/CRL 请求，也可由服务器 stapling 省去外网查询。


## 直播协议有哪些？
RTMP（实时消息传输协议），HLS（HTTP直播流），WebRTC（网页实时通信）。
