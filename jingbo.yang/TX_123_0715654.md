# 腾讯csig暑期实习 一二三面

## redis和mysql如何保证一致性

## redis和mysql如何保证一致性？

## 讲一下DDD的概念，聚合根，实体等具体是指什么？

## 慢查询优化是怎么做的？
## 什么是聚簇索引？
## 联合索引在什么情况下会失效？
## redis 持久化是怎么做的？
aof rdb aof+rdb混合模式
## 跳表是什么？
将链表升级为多层索引结构，提升查找效率。相当于建立了多级索引。

## 缓存击穿，缓存穿透，缓存雪崩的概念和解决方法？
缓存击穿：缓存中不存在某个热点数据，导致大量请求直接打到数据库上。解决方法：使用互斥锁或布隆过滤器。
缓存穿透：请求的数据在缓存和数据库中都不存在，导致每次请求都打到数据库上。解决方法：使用布隆过滤器或缓存空对象。
缓存雪崩：缓存中大量数据同时过期，导致大量请求直接打到数据库上。解决方法：设置不同的过期时间，使用预热机制。
## tcp三次握手和四次挥手的过程是什么样子？

### **一、三次握手（建立连接）的状态转换**  
三次握手的目标是让客户端和服务端确认彼此的发送和接收能力，最终建立双向通信的连接。双方状态变化如下：

| 阶段 | 客户端状态       | 服务端状态       | 动作描述                                                                 |
|------|------------------|------------------|--------------------------------------------------------------------------|
| 初始 | `CLOSED`         | `LISTEN`         | 服务端先启动，进入监听状态（`LISTEN`），等待客户端连接；客户端初始为关闭状态。 |
| 1st  | `SYN_SENT`       | `LISTEN` → `SYN_RCVD` | 客户端发送 `SYN` 报文（请求连接），进入 `SYN_SENT` 状态；服务端收到 `SYN` 后，进入 `SYN_RCVD` 状态，并回复 `SYN+ACK` 报文。 |
| 2nd  | `SYN_SENT` → `ESTABLISHED` | `SYN_RCVD`       | 客户端收到 `SYN+ACK` 后，进入 `ESTABLISHED` 状态，并发送 `ACK` 报文（确认连接）。 |
| 3rd  | `ESTABLISHED`    | `SYN_RCVD` → `ESTABLISHED` | 服务端收到 `ACK` 后，进入 `ESTABLISHED` 状态，双方连接建立，可开始数据传输。 |


#### 关键状态说明：  
- **`LISTEN`**：服务端专用状态，表示已准备好接收连接请求（如 `bind()` 和 `listen()` 后进入此状态）。  
- **`SYN_SENT`**：客户端发送 `SYN` 后进入，等待服务端的 `SYN+ACK` 响应。  
- **`SYN_RCVD`**：服务端收到 `SYN` 后进入，等待客户端的 `ACK` 确认。  
- **`ESTABLISHED`**：连接已建立，双方可正常发送和接收数据（数据传输阶段的主要状态）。  


### **二、四次挥手（断开连接）的状态转换**  
TCP 是全双工通信，断开连接时需要双方分别确认“不再发送数据”，因此需要四次交互。假设客户端先发起断开请求（实际双方均可主动发起）：

| 阶段 | 客户端状态         | 服务端状态         | 动作描述                                                                 |
|------|--------------------|--------------------|--------------------------------------------------------------------------|
| 初始 | `ESTABLISHED`      | `ESTABLISHED`      | 连接处于数据传输状态，双方均为 `ESTABLISHED`。                             |
| 1st  | `ESTABLISHED` → `FIN_WAIT_1` | `ESTABLISHED`      | 客户端主动关闭连接，发送 `FIN` 报文（表示不再发送数据），进入 `FIN_WAIT_1` 状态，等待服务端的 `ACK`。 |
| 2nd  | `FIN_WAIT_1` → `FIN_WAIT_2` | `ESTABLISHED` → `CLOSE_WAIT` | 服务端收到 `FIN` 后，先回复 `ACK` 报文（确认收到关闭请求），进入 `CLOSE_WAIT` 状态（此时服务端仍可向客户端发送数据）；客户端收到 `ACK` 后，进入 `FIN_WAIT_2` 状态，等待服务端的 `FIN`。 |
| 3rd  | `FIN_WAIT_2`       | `CLOSE_WAIT` → `LAST_ACK` | 服务端完成所有数据发送后，发送 `FIN` 报文（表示自己也不再发送数据），进入 `LAST_ACK` 状态，等待客户端的 `ACK`。 |
| 4th  | `FIN_WAIT_2` → `TIME_WAIT` | `LAST_ACK` → `CLOSED` | 客户端收到服务端的 `FIN` 后，回复 `ACK` 报文，进入 `TIME_WAIT` 状态；服务端收到 `ACK` 后，立即进入 `CLOSED` 状态（断开完成）。 |
| 最终 | `TIME_WAIT` → `CLOSED` | `CLOSED`           | 客户端在 `TIME_WAIT` 状态等待 **2MSL（报文最大生存时间，通常为1-4分钟）** 后，确保服务端已收到 `ACK`，最终进入 `CLOSED` 状态。 |


#### 关键状态说明：  
- **`FIN_WAIT_1`**：客户端发送 `FIN` 后，等待服务端 `ACK` 的状态。  
- **`FIN_WAIT_2`**：客户端收到服务端 `ACK` 后，等待服务端 `FIN` 的状态（此时客户端已无法发送数据，但可接收服务端数据）。  
- **`CLOSE_WAIT`**：服务端收到客户端 `FIN` 后，等待自身数据发送完成的状态（需应用层主动调用 `close()` 触发后续 `FIN` 发送）。  
- **`LAST_ACK`**：服务端发送 `FIN` 后，等待客户端 `ACK` 的状态。  
- **`TIME_WAIT`**：客户端发送最后一个 `ACK` 后进入，等待 2MSL 时间，目的是：<br>  1. 确保服务端能收到最后的 `ACK`（若 `ACK` 丢失，服务端会重发 `FIN`，客户端可在 `TIME_WAIT` 内重发 `ACK`）；<br>  2. 避免旧连接的残留报文干扰新连接（2MSL 后，旧报文会被网络丢弃）。  


### **总结**  
- **三次握手**通过 `SYN_SENT`、`SYN_RCVD` 等状态确保双方收发能力正常，最终进入 `ESTABLISHED` 状态。  
- **四次挥手**通过 `FIN_WAIT`、`CLOSE_WAIT`、`TIME_WAIT` 等状态处理全双工连接的有序关闭，尤其是 `TIME_WAIT` 状态是保证 TCP 可靠性的关键设计。  

## 拥塞窗口和接收窗口的区别？
拥塞窗口（cwnd）：TCP协议中用于控制发送方发送数据的速率，防止网络拥塞。它是根据网络状况动态调整的。  
接收窗口（rwnd）：TCP协议中用于控制接收方能够接收的数据量。它是由接收方根据自身缓冲区大小决定的。  
这两者共同决定了tcp连接的滑动窗口大小；

### 拥塞窗口在什么情况下大小会变成当前大小的一半？？
以下是TCP核心概念及特点的总结表格，涵盖拥塞控制、窗口机制等关键内容：

| **概念**         | **全称/含义**                          | **核心特点**                                                                                                                                 | **作用场景**                                                                 |
|------------------|---------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|
| **TCP**          | Transmission Control Protocol         | 面向连接、可靠传输、字节流服务、全双工通信；通过序号、确认、重传等机制保证可靠性。                                                             | 需可靠数据传输的场景（如HTTP、FTP、邮件等）。                               |
| **拥塞窗口（cwnd）** | Congestion Window                     | 发送方根据网络拥塞状况动态调整的窗口大小，控制发送速率；大小由拥塞控制算法决定。                                                               | 避免网络因发送数据过多而拥塞。                                               |
| **接收窗口（rwnd）** | Receive Window                        | 接收方告知发送方的缓冲区剩余容量，是TCP流量控制的核心参数；随接收方处理能力动态变化。                                                         | 防止发送方发送速率超过接收方处理能力（流量控制）。                           |
| **滑动窗口**     | Sliding Window                        | 实际发送窗口大小 = min(cwnd, rwnd)；发送方通过窗口滑动确认已接收数据，未确认数据需重传。                                                       | 实现TCP的流量控制与可靠传输，提高传输效率。                                 |
| **慢启动阈值（ssthresh）** | Slow Start Threshold                  | 拥塞控制中慢启动与拥塞避免阶段的分界值；当cwnd < ssthresh时进入慢启动，≥ssthresh时进入拥塞避免。                                               | 调节拥塞窗口增长方式，平衡带宽利用与拥塞风险。                               |
| **慢启动**       | Slow Start                            | cwnd < ssthresh时，cwnd按指数增长（每轮RTT翻倍）；初始值通常为1-2个MSS。                                                                       | 连接建立初期或超时重传后，快速探测网络可用带宽。                             |
| **拥塞避免**     | Congestion Avoidance                  | cwnd ≥ ssthresh时，cwnd按线性增长（每轮RTT增加1个MSS）。                                                                                       | 接近网络承载上限时，平稳增长发送速率，减少拥塞概率。                         |
| **快重传**       | Fast Retransmit                       | 收到连续3个重复ACK时，立即重传丢失的报文段，无需等待超时。                                                                                     | 快速修复报文丢失，减少重传延迟。                                             |
| **快恢复**       | Fast Recovery                         | 快重传触发后，将ssthresh设为当前cwnd的一半，cwnd设为新ssthresh，随后进入拥塞避免阶段（线性增长）。                                               | 网络未完全拥塞时（仅部分丢包），快速恢复传输速率，避免过度降低发送效率。     |
| **超时重传**     | Timeout Retransmission                | 发送方未在超时时间内收到ACK，判定报文丢失，重传该报文；触发后将ssthresh设为当前cwnd的一半，cwnd重置为初始值（1个MSS），重新进入慢启动。         | 网络严重拥塞（如大量丢包）时，彻底降低发送速率，重新探测网络。               |
| **ACK**          | Acknowledgment                        | 接收方对已接收数据的确认；包含期望接收的下一字节序号，可携带rwnd信息。                                                                         | 确认数据接收状态，触发发送方窗口调整（如cwnd增长、滑动窗口移动）。           |
| **MSS**          | Maximum Segment Size                  | TCP报文段的最大数据部分长度（不含首部）；由通信双方协商确定，通常与链路MTU（最大传输单元）匹配。                                               | 避免IP层分片，提高传输效率。                                                 |

## 算法
- 三数之和
- 原地删除重复元素，最多重复两次，返回新的长度

# 三面

算法：左右括号匹配
## 实习最大的挑战是什么？
开发效率
## 对于CDN业务的了解
CDN（内容分发网络）是通过在全球各地部署边缘节点，将静态资源缓存到离用户更近的服务器上，以减少延迟和提高访问速度。
## TCP和UDP的区别

