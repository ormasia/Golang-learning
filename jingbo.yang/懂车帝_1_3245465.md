- [懂车帝后端一面 面经](#懂车帝后端一面-面经)
  - [项目中设计过哪些表，设计思路是什么？](#项目中设计过哪些表设计思路是什么)
    - [为什么不用 UUID 做主键？](#为什么不用-uuid-做主键)
    - [软删后索引仍占空间？](#软删后索引仍占空间)
    - [为什么小表驱动大表？](#为什么小表驱动大表)
  - [mysql索引](#mysql索引)
  - [B+树](#b树)
  - [mysql中的数据类型底层怎么存的？（当时没理解，然后面试官提示比如INT，TIME，但是答的感觉一般）](#mysql中的数据类型底层怎么存的当时没理解然后面试官提示比如inttime但是答的感觉一般)
    - [MySQL数据类型底层存储](#mysql数据类型底层存储)
  - [mysql基础架构](#mysql基础架构)
    - [MySQL架构详解](#mysql架构详解)
  - [mysql的事物隔离级别有哪些？](#mysql的事物隔离级别有哪些)
    - [事务隔离级别详解](#事务隔离级别详解)
  - [mvcc是什么，原理是什么？](#mvcc是什么原理是什么)
    - [MVCC多版本并发控制](#mvcc多版本并发控制)
  - [悲观锁和乐观锁讲一下](#悲观锁和乐观锁讲一下)
    - [锁机制对比](#锁机制对比)
  - [数据库范式有哪些？](#数据库范式有哪些)
    - [数据库范式详解](#数据库范式详解)
  - [HTTP协议和TCP协议的区别是什么？](#http协议和tcp协议的区别是什么)
    - [HTTP vs TCP对比](#http-vs-tcp对比)
  - [七层网络协议有哪些？](#七层网络协议有哪些)
    - [OSI七层模型(正确顺序)](#osi七层模型正确顺序)
  - [UDP协议是什么？](#udp协议是什么)
    - [UDP协议特点](#udp协议特点)
  - [常见linux命令有哪些？](#常见linux命令有哪些)
    - [Linux常用命令分类](#linux常用命令分类)
  - [查看CPU负载内存使用率这些比如用哪些命令？（只答上来了top）](#查看cpu负载内存使用率这些比如用哪些命令只答上来了top)
    - [系统监控命令大全](#系统监控命令大全)
  - [用户态和内核态有了解吗？](#用户态和内核态有了解吗)
    - [用户态vs内核态详解](#用户态vs内核态详解)
  - [进程和线程的区别](#进程和线程的区别)
    - [进程vs线程详细对比](#进程vs线程详细对比)
  - [进程间通信](#进程间通信)
    - [IPC机制详解](#ipc机制详解)
  - [redis和kafka有了解吗？](#redis和kafka有了解吗)
    - [Redis深度解析](#redis深度解析)
    - [Kafka深度解析](#kafka深度解析)
  - [kafka基础组件有什么？](#kafka基础组件有什么)
    - [Kafka组件详解](#kafka组件详解)
  - [redis的基础类型](#redis的基础类型)
    - [Redis数据类型详解](#redis数据类型详解)
  - [redis列表底层数据结构是什么？标记](#redis列表底层数据结构是什么标记)
  - [redis的哈希类型的结构是什么？](#redis的哈希类型的结构是什么)
    - [Redis Hash底层实现](#redis-hash底层实现)
  - [redis的删除策略有哪些？](#redis的删除策略有哪些)
    - [Redis过期删除策略](#redis过期删除策略)
  - [redis的分布式锁是什么？](#redis的分布式锁是什么)
    - [Redis分布式锁详解](#redis分布式锁详解)

# 懂车帝后端一面 面经
自我介绍

## 项目中设计过哪些表，设计思路是什么？
- 字段符合三范式，不可分，唯一依赖，有依赖？

  |范式|	要求|
  |---|---|
  |第一范式 (1NF)|	字段原子性，不可再分|
  |第二范式 (2NF)|	在 1NF 基础上，非主键字段必须完全依赖于整个主键(复合主键情况下)。|
  |第三范式 (3NF)|	在 2NF 基础上，非主键字段不能依赖于其他非主键字段。|


- 表之间需要考虑关联关系，小表驱动大表，表的数据量大小，是否需要分片
- 索引，索引的选择，索引的类型，索引的使用场景

  *设计过任务表，任务配置表，任务调度表*

“在任务表中，我们对任务ID设置了主键索引以保证唯一和快速查找，对创建时间设置了普通索引以优化按时间范围查询的场景。任务状态字段也建立了索引，方便快速筛选不同状态的任务。”  
**同时删除字段采取软删除，保证时间索引的插入是顺序的，不要频繁的插入和删除，导致索引的碎片化。**  
### 为什么不用 UUID 做主键？	
雪花或自增主键顺序写，B+Tree 不分裂；UUID 随机写容易碎片 + Page Split。

### 软删后索引仍占空间？	
周期性把 is_deleted=1 AND deleted_at<30d 的分区归档或 ALTER TABLE … DROP PARTITION，磁盘瞬时释放。

ALTER TABLE 是用于修改表结构的 SQL 语句，DROP PARTITION 则是其中的一个子句，用于删除表中的指定分区。当执行 ALTER TABLE … DROP PARTITION 语句时，数据库会立即从磁盘上删除指定分区的数据和相关索引，从而实现磁盘空间的瞬时释放。

```sql
-- 创建一个按日期范围分区的表
CREATE TABLE orders (
    id INT,
    order_date DATE,
    is_deleted TINYINT(1),
    deleted_at DATE
)
PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
);

-- 假设我们要删除 p2022 分区（该分区中可能包含很多软删除的数据）
ALTER TABLE orders DROP PARTITION p2022;
```

### 为什么小表驱动大表？


- 扫描次数：如果使用小表作为驱动表，由于小表的数据量少，外层循环的次数就少，这样扫描大表的总次数也会相应减少，从而降低了整体的 I/O 开销和 CPU 处理时间。
   
      意思是：  
      10 + 10 * 1000 = 10010 次扫描；  
      1000 + 1000 * 10 = 11000 次扫描。
  
- 缓存命中率：小表的数据更容易全部加载到内存中，从而提高缓存命中率，减少磁盘 I/O 操作。

## mysql索引

聚簇索引，非聚簇索引；  
唯一索引，主键索引；  
复合索引(覆盖索引)；  
普通索引，全文索引；  

    *   “主键索引保证了数据的唯一性，并且通常是聚簇索引，物理存储顺序与逻辑顺序一致。”
    *   “覆盖索引是通过复合索引实现的，当查询的字段都在索引中时，可以直接从索引返回结果，无需回表，效率很高。”

## B+树
叶子节点存储数据，非叶子节点存储索引；
- B+树的高度低，查询效率高；
- 叶子节点是双向连接，支持范围查询；


1.  **为何高效**：高度低，减少磁盘I/O次数
2.  **范围查询优势**：“支持范围查询”是（叶子节点之间通过指针相连，形成有序链表）。
3.  **与B树对比**：对比B+树相对于B树在数据库索引方面的优势（如B+树更适合范围查询，所有数据都在叶子节点）。

## mysql中的数据类型底层怎么存的？（当时没理解，然后面试官提示比如INT，TIME，但是答的感觉一般）

### MySQL数据类型底层存储

| 类型        | 字节数 | 范围/格式/描述                  |
|-------------|--------|---------------------------------|
| **整数类型** |        |                                 |
| TINYINT     | 1      | -128到127                      |
| INT         | 4      | 约-21亿到21亿                  |
| BIGINT      | 8      | 约-922万亿到922万亿            |
| **时间类型** |        |                                 |
| TIME        | 3      | HH:MM:SS                       |
| DATE        | 3      | YYYY-MM-DD                     |
| DATETIME    | 8      | YYYY-MM-DD HH:MM:SS            |
| TIMESTAMP   | 4      | 存储UTC时间戳；UTC 时间戳是一个整数，表示自 1970 年 1 月 1 日 00:00:00 UTC 起的秒数或毫秒数。|
| **字符类型** |        |                                 |
| CHAR(n)     |        | 固定长度，不足用空格填充       |
| VARCHAR(n)  |        | 变长，需要1-2字节存储长度信息  |
| TEXT        |        | 变长，最大65535字节            |
| **浮点类型** |        |                                 |
| FLOAT       | 4      | 单精度                         |
| DOUBLE      | 8      | 双精度                         |
## mysql基础架构
server层，引擎层；

### MySQL架构详解
```
┌─────────────────────────────────────┐
│              客户端层               │
├─────────────────────────────────────┤
│              Server层               │
│  ┌─────────┬─────────┬─────────────┐│
│  │连接器   │查询缓存 │    分析器   ││
│  ├─────────┼─────────┼─────────────┤│
│  │优化器   │执行器   │              ││
│  └─────────┴─────────┴─────────────┘│
├─────────────────────────────────────┤
│            存储引擎层               │
│       InnoDB  MyISAM  Memory       │
└─────────────────────────────────────┘
```

**Server层组件**：
- **连接器**: 管理连接、权限验证
- **查询缓存**: 缓存查询结果(MySQL 8.0已移除)
- **分析器**: 词法分析、语法分析
- **优化器**: 选择最优执行计划
- **执行器**: 执行SQL、调用存储引擎API

## mysql的事物隔离级别有哪些？
|隔离级别|	问题|	特点|
|---|---|---|
|READ UNCOMMITTED (RU)|	脏读、不可重复读、幻读|	性能最高，一致性最差|
|READ COMMITTED (RC)|	不可重复读、幻读|	每次查询生成新 ReadView|
|REPEATABLE READ (RR)|	幻读（部分解决）|	事务开始时生成 ReadView，MySQL InnoDB 默认|
|SERIALIZABLE|	无并发问题|	性能最低，一致性最强|

1.  **MySQL默认级别**：提到MySQL InnoDB默认的是Repeatable Read。

### 事务隔离级别详解
1. **READ UNCOMMITTED(RU)**: 读未提交
   - 问题：脏读、不可重复读、幻读
   - 性能：最高，一致性最差

2. **READ COMMITTED(RC)**: 读已提交  
   - 问题：不可重复读、幻读
   - 特点：每次查询都生成新的ReadView

3. **REPEATABLE READ(RR)**: 可重复读(MySQL默认)
   - 问题：幻读(部分解决)
   - 特点：事务开始时生成ReadView

4. **SERIALIZABLE**: 串行化
   - 问题：无并发问题
   - 性能：最低，一致性最强

## mvcc是什么，原理是什么？
readview undolog版本链

“MVCC（多版本并发控制）是通过`版本链（Version Chain）`、`undo log` 和 `ReadView` 机制来实现的。当数据被修改时，旧版本会存入`undo log`形成版本链。事务在读取数据时，会根据当前事务的`ReadView`（包含当前活跃事务列表等信息）去版本链中查找可见的版本，从而实现在不加锁的情况下处理读写冲突，提高并发性能。”

### MVCC多版本并发控制
**核心组件**：
1. **版本链**: 每行记录的多个版本通过roll_pointer连接,基于undo log实现
2. **ReadView**: 记录当前活跃事务ID列表
3. **undo log**: 存储历史版本数据

**工作原理**：
```sql
-- 示例：两个事务并发修改同一行
事务A(ID=100): UPDATE user SET name='张三' WHERE id=1;
事务B(ID=101): SELECT name FROM user WHERE id=1;
```

**ReadView结构**：
- `m_ids`: 活跃事务ID列表[99,101]
- `min_trx_id`: 最小活跃事务ID(99)
- `max_trx_id`: 下一个分配的事务ID(102)

**可见性判断**：
- 如果`trx_id < min_trx_id`: 可见
- 如果`trx_id >= max_trx_id`: 不可见  
- 如果`trx_id in m_ids`: 不可见
- 否则：可见

## 悲观锁和乐观锁讲一下
悲观锁是认为每次需要上锁和解锁  
乐观锁通过版本号实现数据保护，


1.  **核心思想**：悲观锁“假定会发生冲突，屏蔽一切可能违反数据完整性的操作”，乐观锁“假定不会发生冲突，在提交更新时检查”。
2.  **实现方式举例**：除了*版本号*，乐观锁也可以用*时间戳*。悲观锁的例子可以是数据库的 `SELECT ... FOR UPDATE`。
3.  **适用场景**：悲观锁适合写多读少的场景，保证数据一致性。乐观锁适合读多写少的场景，提高并发。

### 锁机制对比
**悲观锁(Pessimistic Lock)**：
```sql
-- 假设冲突一定发生，先加锁再操作
SELECT * FROM account WHERE id=1 FOR UPDATE;
UPDATE account SET balance=balance-100 WHERE id=1;
```
- 优点：数据一致性强
- 缺点：并发性能差，可能死锁

**乐观锁(Optimistic Lock)**：
```sql
-- 假设冲突很少发生，提交时检查
SELECT balance, version FROM account WHERE id=1;
-- 业务逻辑处理
UPDATE account SET balance=900, version=version+1 
WHERE id=1 AND version=老版本号;
```
- 优点：并发性能好，无死锁
- 缺点：冲突时需要重试

## 数据库范式有哪些？
三范式

1.  **第一范式 (1NF)**：确保字段的原子性，不可再分。
2.  **第二范式 (2NF)**：在1NF基础上，消除部分函数依赖，即非主键字段完全依赖于主键。
3.  **第三范式 (3NF)**：在2NF基础上，消除传递函数依赖，即非主键字段不依赖于其他非主键字段。
“实际设计中，有时会为了性能考虑适度反范式。”

### 数据库范式详解
**第一范式(1NF)**: 原子性
- 每个字段都是不可分割的原子项
- 例：地址不能存"北京市朝阳区建国路1号"，应拆分为省、市、区、详细地址

**第二范式(2NF)**: 完全函数依赖
- 满足1NF且非主键字段完全依赖于主键
- 例：订单表(订单ID, 商品ID, 商品名称, 数量)违反2NF，商品名称只依赖商品ID

**第三范式(3NF)**: 消除传递依赖  
- 满足2NF且非主键字段不依赖于其他非主键字段
- 例：学生表(学号, 姓名, 院系, 院长)违反3NF，院长依赖于院系

## HTTP协议和TCP协议的区别是什么？
应用层和传输层

1.  **目的/功能**：TCP 负责提供可靠的、面向连接的字节流传输服务。HTTP 则是在 TCP 之上，定义了客户端和服务器之间请求和响应的格式和规则，用于传输超文本等资源。
2.  **连接性**：TCP 是面向连接的（三次握手、四次挥手）。HTTP/1.0 默认短连接，HTTP/1.1 支持持久连接和管道化，HTTP/2 支持多路复用（都基于TCP连接）。
3.  **状态**：TCP 本身不关心传输内容的状态。HTTP 是无状态协议，但可以通过 Cookie/Session 等机制来维护状态。
“TCP是修路（保证数据可靠送达），HTTP是在路上跑的车（定义传输的内容和方式）。”

### HTTP vs TCP对比
**协议层次**：
- HTTP：应用层协议，基于TCP实现
- TCP：传输层协议，负责可靠数据传输

**功能职责**：
- **HTTP**: 定义数据格式(请求/响应报文)、状态码、头部信息
- **TCP**: 提供连接管理、流量控制、拥塞控制、可靠传输

**连接特性**：
- **HTTP/1.1**: 持久连接，一个TCP连接可发送多个HTTP请求(长连接)
- **HTTP/2**: 多路复用，一个TCP连接并发处理多个请求
- **TCP**: 面向连接，三次握手建立，四次挥手断开

## 七层网络协议有哪些？
物理层 数据链路层 网络层 传输层 应用层 会话层 表示层

1.  **挑选1-2层简述功能**：例如，“网络层主要通过IP协议进行路由选择和寻址，传输层有TCP和UDP，TCP提供可靠传输，UDP提供快速但不可靠的传输。”
2.  **提及TCP/IP四层模型（可选）**：可以说OSI七层是理论模型，实际应用中TCP/IP四层（或五层）模型更常见

### OSI七层模型(正确顺序)
1. **物理层(Physical)**: 比特流传输，网线、光纤
2. **数据链路层(Data Link)**: 帧传输，以太网、WiFi  
3. **网络层(Network)**: 路由选择，IP协议
4. **传输层(Transport)**: 端到端传输，TCP、UDP
5. **会话层(Session)**: 会话管理，建立、维护、终止会话
6. **表示层(Presentation)**: 数据格式化，加密、压缩
7. **应用层(Application)**: 用户接口，HTTP、FTP、SMTP

**记忆口诀**: "物数网传会表应"

## UDP协议是什么？
无连接的数据报协议

1.  **特性**：除了无连接，还包括不可靠传输（不保证到达、不保证顺序、不保证不重复）、头部开销小、传输效率高。
2.  **与TCP对比**：简单对比一下与TCP的主要区别（可靠性、连接管理、速度）。
3.  **应用场景**：DNS查询、视频直播、在线游戏等对实时性要求高、能容忍少量丢包的场景。

### UDP协议特点
**基本特性**：
- **无连接**: 发送前无需建立连接
- **不可靠**: 不保证数据到达、顺序、去重
- **面向数据报**: 有明确的消息边界
- **简单高效**: 头部仅8字节，无流量控制

**UDP vs TCP对比**：
| 特性 | UDP | TCP |
|------|-----|-----|
| 连接 | 无连接 | 面向连接 |
| 可靠性 | 不可靠 | 可靠传输 |
| 速度 | 快 | 相对慢 |
| 头部开销 | 8字节 | 20字节 |

**应用场景**：
- DNS查询、在线游戏、视频直播
- 要求实时性高、可容忍少量数据丢失

## 常见linux命令有哪些？

💡 **优化回答建议：**
1.  **文件和目录操作**：`ls` (列出目录内容), `cd` (切换目录), `mkdir` (创建目录), `rm` (删除文件/目录), `cp` (复制), `mv` (移动/重命名), `pwd` (显示当前路径)。
2.  **文本查看和处理**：`cat` (查看小文件), `less`/`more` (分页查看大文件), `head`/`tail` (查看文件头/尾), `grep` (文本搜索)。
3.  **系统信息和监控**：`top`/`htop` (查看系统进程和资源占用), `df` (磁盘空间), `free` (内存使用), `ps` (查看进程)。
4.  **网络相关**：`ping` (测试网络连通性), `ifconfig`/`ip addr` (查看网络接口信息), `netstat`/`ss` (查看网络连接)。

### Linux常用命令分类
**文件操作**：
- `ls -la`: 列出文件详细信息
- `cd /path`: 切换目录
- `cp/mv/rm`: 复制/移动/删除
- `find /path -name "*.log"`: 查找文件
- `chmod 755 file`: 修改权限

**文本处理**：
- `cat/head/tail`: 查看文件内容
- `grep "keyword" file`: 文本搜索
- `awk/sed`: 文本处理
- `sort/uniq`: 排序去重

**系统监控**：
- `ps aux`: 查看进程
- `top/htop`: 实时系统状态
- `df -h`: 磁盘使用情况
- `free -h`: 内存使用情况
- `netstat -an`: 网络连接状态

## 查看CPU负载内存使用率这些比如用哪些命令？（只答上来了top）

`top` 是一个非常核心的命令。除此之外，你还可以补充几个专注于特定资源的命令，并说明它们的主要用途：
*   **`vmstat`**：可以实时显示虚拟内存、进程、CPU活动等信息。例如 `vmstat 1` 每秒刷新一次。
   
|分类|具体指标|含义|输出值解读|
|----|----|----|----|
|进程相关<br>（procs）|r|等待运行在 CPU 上的进程数量，也称为运行队列长度。若该值持续大于 CPU 核心数，表明系统可能存在 CPU 瓶颈|输出值为 0，说明当前没有进程在等待 CPU 资源|
||b|处于不可中断睡眠状态的进程数量，通常是在等待 I/O 操作完成|输出值为 0，意味着没有进程处于这种等待 I/O 的状态|
|内存相关<br>（memory）|swpd|已使用的交换分区（swap）的大小（单位为 KB）|输出值为 0，表明系统当前没有使用交换分区，内存较为充足|
||free|空闲的物理内存大小（单位为 KB）|输出值是 6051608KB，说明系统有大量的空闲物理内存|
||buff|用于块设备的缓冲区内存大小（单位为 KB）|输出值是 63316KB，这部分内存用于提高磁盘 I/O 性能|
||cache|用于文件系统的缓存内存大小（单位为 KB）|输出值为 858548KB，有助于加快文件的读取速度|
|交换分区相关<br>（swap）|si|从磁盘交换到内存的交换页数量，单位是每秒（pages/s）|输出值为 0，表示没有数据从交换分区换入内存|
||so|从内存交换到磁盘的交换页数量，单位是每秒（pages/s）|输出值为 0，说明没有数据从内存换出到交换分区|
|I/O 操作相关<br>（io）|bi|从块设备（如磁盘）读取的块数量，单位是每秒（blocks/s）|输出值是 911，意味着每秒从块设备读取 911 个块|
||bo|写入到块设备的块数量，单位是每秒（blocks/s）|输出值为 80，表示每秒向块设备写入 80 个块|
|系统相关<br>（system）|in|每秒的中断次数，包括时钟中断、硬件中断等|输出值是 454，即每秒发生 454 次中断|
||cs|每秒的上下文切换次数|输出值为 296，说明每秒发生 296 次上下文切换|
|CPU 使用情况相关<br>（cpu）|us|用户进程使用 CPU 的时间百分比|输出值是 2，表示用户进程占用 CPU 时间的比例为 2%|
||sy|系统进程使用 CPU 的时间百分比|输出值为 2，意味着系统进程占用 CPU 时间的比例为 2%|
||id|CPU 处于空闲状态的时间百分比|输出值是 95，表明 CPU 有 95% 的时间处于空闲状态|
||wa|CPU 等待 I/O 完成的时间百分比|输出值为 1，说明 CPU 有 1% 的时间在等待 I/O 操作完成|
||st|被虚拟机偷走的 CPU 时间百分比（如果是虚拟机环境）|输出值为 0，表示没有 CPU 时间被虚拟机占用|

*   **`free -h`**：专门用于查看内存和交换空间的使用情况，`-h`使其更易读。
*   **`iostat`**：用于监控CPU使用情况以及磁盘I/O活动。
*   **`uptime`**：快速查看系统运行时间及平均负载（load average）。

### 系统监控命令大全
**CPU监控**：
- `top`: 实时进程和CPU使用率
- `htop`: 更友好的top界面
- `vmstat 1`: 每秒显示系统统计信息
- `sar -u 1`: CPU使用率历史数据
- `uptime`: 系统负载平均值

**内存监控**：
- `free -h`: 内存使用情况(人类可读格式)
- `cat /proc/meminfo`: 详细内存信息
- `ps aux --sort=-rss`: 按内存使用排序进程

**磁盘I/O**：
- `iostat -x 1`: 磁盘I/O统计
- `iotop`: 实时I/O使用情况
- `df -h`: 磁盘空间使用

**网络监控**：
- `netstat -i`: 网络接口统计
- `ss -tuln`: 查看监听端口
- `iftop`: 实时网络流量

## 用户态和内核态有了解吗？
用户态是程序员的可以接触的层级，不能访问关键内存，内核与用户转换需要消耗资源
内核态是操作系统内部保护的程序段，操作关键函数

1.  **目的**：主要是为了**系统安全和稳定**。内核态拥有最高权限，可以直接操作硬件和管理所有系统资源。用户态权限受限，防止应用程序直接破坏系统。
2.  **资源隔离**：用户态程序有自己独立的地址空间，内核态则共享同一地址空间。
3.  **切换方式**：从用户态到内核态的切换通常通过**系统调用（System Call）**、**中断（Interrupt）**或**异常（Exception）**来触发。
4.  **开销**：提到切换有开销是很好的点，可以补充说明**开销主要在于上下文保存和恢复**。

### 用户态vs内核态详解
**用户态(User Mode)**：
- **权限**: 只能访问用户空间内存(0-3GB)
- **指令**: 只能执行非特权指令
- **安全**: 程序崩溃不会影响系统稳定性
- **示例**: 应用程序、用户进程

**内核态(Kernel Mode)**：
- **权限**: 可访问所有内存空间(0-4GB)
- **指令**: 可执行所有指令，包括特权指令
- **功能**: 管理硬件资源、文件系统、网络等
- **示例**: 系统调用、设备驱动、中断处理

**切换场景**：
1. **系统调用**: read()、write()、open()等
2. **中断**: 硬件中断、时钟中断
3. **异常**: 缺页异常、除零异常

**切换开销**：
- 保存/恢复寄存器状态
- 切换内存映射
- 刷新CPU缓存
- 开销约几十到几百个CPU周期

## 进程和线程的区别
资源分配的最小单位
操作系统最小的调度单位

1.  **资源拥有**：进程是资源分配的基本单位，拥有独立的地址空间、文件描述符等。一个进程内的多个线程共享这些资源（除了线程各自的栈、程序计数器等私有数据）。
2.  **并发性**：两者都可以并发执行。多线程主要在同一进程内实现并发，开销小；多进程并发开销大，但更稳定。
3.  **开销**：线程的创建、销毁、切换开销远小于进程。
4.  **通信**：线程间通信因为共享内存所以更方便。进程间通信（IPC）需要专门的机制（如管道、共享内存、消息队列等）。
5.  **影响**：*一个线程崩溃可能导致整个进程退出，而一个进程崩溃通常不直接影响其他进程*。

### 进程vs线程详细对比
**定义区别**：
- **进程**: 资源分配的基本单位，拥有独立的内存空间
- **线程**: CPU调度的基本单位，共享进程的内存空间

**具体对比**：
| 方面 | 进程 | 线程 |
|------|------|------|
| 内存空间 | 独立的虚拟地址空间 | 共享进程地址空间 |
| 创建开销 | 大(需要分配内存空间) | 小(只需要分配栈) |
| 通信方式 | IPC(管道、消息队列等) | 共享内存、信号量 |
| 安全性 | 进程崩溃不影响其他进程 | 线程崩溃可能影响整个进程 |
| 切换开销 | 大(需要切换地址空间) | 小(只需要切换寄存器) |

**内存布局**：
```
进程A                  进程B
┌─────────┐          ┌─────────┐
│ 代码段  │          │ 代码段  │
├─────────┤          ├─────────┤
│ 数据段  │          │ 数据段  │
├─────────┤          ├─────────┤
│线程1栈  │          │线程1栈  │
├─────────┤          ├─────────┤
│线程2栈  │          │线程2栈  │
└─────────┘          └─────────┘
```

## 进程间通信
共享内存
管道
消息队列
socket
信号量

*   **管道 (Pipe)**：常用于有亲缘关系的进程间单向通信，如父子进程。分为匿名管道和命名管道。
*   **共享内存 (Shared Memory)**：效率最高的IPC方式，多个进程共享同一块物理内存。需要配合信号量等同步机制使用，避免冲突。
*   **消息队列 (Message Queue)**：克服了管道和共享内存的一些限制，消息以队列形式存储，可以实现异步通信，不要求收发进程同时存在。
*   **Socket**：不仅用于同一主机的进程间通信，更常用于不同主机间的网络通信。
*   **信号量 (Semaphore)**：主要用作同步和互斥机制，控制对共享资源的访问，本身不传递复杂数据。

### IPC机制详解
**1. 管道(Pipe)**：
```bash
# 匿名管道
ls | grep "txt"
# 命名管道(FIFO)
mkfifo mypipe
```
- 特点：半双工，数据单向流动
- 适用：父子进程间通信

**2. 共享内存(Shared Memory)**：
```c
int shmid = shmget(key, size, IPC_CREAT);
void *ptr = shmat(shmid, NULL, 0);
```
- 特点：效率最高，直接内存访问
- 缺点：需要同步机制保护

**3. 消息队列(Message Queue)**：
```c
int msgid = msgget(key, IPC_CREAT);
msgsnd(msgid, &msg, sizeof(msg), 0);
```
- 特点：异步通信，有消息类型
- 优点：支持多种消息格式

**4. 信号量(Semaphore)**：
```c
int semid = semget(key, 1, IPC_CREAT);
semop(semid, &sop, 1);  // P操作
```
- 特点：主要用于同步，不传递数据
- 作用：控制临界资源访问

**5. Socket**：
```c
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
connect(sockfd, &addr, sizeof(addr));
```
- 特点：可跨主机通信
- 类型：TCP、UDP

**6. 信号(Signal)**：
```c
signal(SIGINT, handler);
kill(pid, SIGTERM);
```
- 特点：异步事件通知
- 常用：SIGKILL、SIGTERM、SIGINT

## redis和kafka有了解吗？
redis属于是NoSql数据库，常用于缓存中间件，分布式锁，消息队列；
kafka是消息队列，具有高可用，高性能等特点，有生产者消费者和broker关键概念，使用零拷贝和顺序写入保证高性能；

*   **Redis**：更侧重于**低延迟、高并发的读写访问**，非常适合作为缓存、会话存储、排行榜、计数器等场景。虽然也能做消息队列，但通常是轻量级的。
*   **Kafka**：设计目标是**高吞吐量、可持久化的分布式消息系统**，特别适合大规模日志收集、流式数据处理、事件溯源等场景。它的消息持久化和分区机制使其能处理海量数据。

### Redis深度解析
**核心特性**：
- **数据结构**: String、Hash、List、Set、ZSet、Bitmap、HyperLogLog
- **持久化**: RDB快照 + AOF日志
- **高可用**: 主从复制、哨兵模式、集群模式
- **性能**: 单线程模型、内存存储、IO多路复用

**应用场景**：
1. **缓存**: 热点数据缓存，减少数据库压力
2. **分布式锁**: SET key value NX EX 30
3. **消息队列**: List的LPUSH/RPOP实现
4. **计数器**: INCR原子操作
5. **排行榜**: ZSet有序集合
6. **会话存储**: 分布式session管理

### Kafka深度解析
**核心架构**：
```
Producer → Broker(Topic/Partition) → Consumer
```

**关键概念**：
- **Topic**: 消息主题，逻辑概念
- **Partition**: 物理存储单元，实现并行处理
- **Broker**: Kafka服务器节点
- **Producer**: 消息生产者
- **Consumer**: 消息消费者
- **Consumer Group**: 消费者组，实现负载均衡

**高性能原理**：
1. **顺序写入**: 磁盘顺序写比随机写快3个数量级
2. **零拷贝**: sendfile()系统调用，减少内核态/用户态切换
3. **批量处理**: 批量发送/接收消息
4. **页缓存**: 利用操作系统页缓存
5. **压缩**: 支持gzip、snappy、lz4等压缩算法

## kafka基础组件有什么？

1.  **Producer (生产者)**：负责发布消息到Kafka的Topic。
2.  **Consumer (消费者)**：负责从Topic订阅并处理消息。消费者通常属于一个Consumer Group。
3.  **Broker (服务节点)**：Kafka集群中的服务器，负责存储消息、处理来自生产者和消费者的请求。一个集群通常由多个Broker组成。
4.  **Topic (主题)**：消息的逻辑分类，生产者发布消息到特定Topic，消费者订阅特定Topic。
5.  **Partition (分区)**：Topic可以被分成多个Partition，这是Kafka实现并行处理和高吞吐量的关键。每个Partition内的消息是有序的。
6.  **Zookeeper**：Kafka依赖Zookeeper进行集群协调管理，如Broker注册、Controller选举、元数据存储等。（较新版本的Kafka正在逐步移除对Zookeeper的强依赖，但面试中提及仍是加分项）。
从这几个主要组件入手，能构建起对Kafka架构的基本描述。

### Kafka组件详解
**核心组件**：
1. **Producer**: 消息生产者
   - 发送消息到指定Topic
   - 支持同步/异步发送
   - 可指定分区策略

2. **Broker**: 服务端
   - 存储和转发消息
   - 管理Topic和Partition
   - 处理Producer和Consumer请求

3. **Consumer**: 消息消费者
   - 从Topic订阅消息
   - 维护消费位移(offset)
   - 支持自动/手动提交

4. **Zookeeper**: 协调服务
   - 存储集群元数据
   - 选举Controller
   - 管理Broker注册

**数据结构**：
```
Topic: 用户行为日志
├── Partition 0: [msg1, msg2, msg3...]
├── Partition 1: [msg4, msg5, msg6...]
└── Partition 2: [msg7, msg8, msg9...]
```

**消费模型**：
- **点对点**: 一个消息只被一个消费者消费
- **发布/订阅**: 一个消息可被多个消费者组消费

## redis的基础类型
string list set zset map geo bitmap

你列出的数据类型很全面（注意：Redis中通常称 `Hash` 而不是 `map`，虽然功能类似）。为了让回答更生动，可以为其中2-3个核心类型补充一个典型应用场景：
*   **String**: 最基础的类型，适合做缓存（如缓存用户信息）、计数器（如文章点赞数）。
*   **Hash**: 适合存储对象结构，比如存储一个用户的多个字段（用户名、年龄、邮箱等）。
*   **List**: 可以用作简单的消息队列（LPUSH/RPOP）或存储有序序列（如用户最近浏览的商品）。
*   **Set**: 无序集合，适合存储不重复的数据，如标签系统（一篇文章的多个标签）、共同好友计算。
*   **ZSet (Sorted Set)**: 有序集合，每个元素关联一个分数，适合做排行榜（如游戏积分榜）、带权重的任务队列。
这样能表明你不仅知道有哪些类型，还知道怎么用它们。

### Redis数据类型详解
**1. String（字符串）**：
```redis
SET key value    # 设置值
GET key         # 获取值
INCR counter    # 原子递增
```
- 应用：缓存、计数器、分布式锁

**2. Hash（哈希表）**：
```redis
HSET user:1 name "张三" age 25
HGET user:1 name
HGETALL user:1
```
- 应用：对象存储、购物车

**3. List（链表）**：
```redis
LPUSH queue task1 task2    # 左侧入队
RPOP queue                 # 右侧出队
```
- 应用：消息队列、最新动态列表

**4. Set（集合）**：
```redis
SADD tags redis mysql go   # 添加元素
SISMEMBER tags redis       # 检查是否存在
SINTER set1 set2          # 交集运算
```
- 应用：标签系统、好友关系、去重

**5. ZSet（有序集合）**：
```redis
ZADD ranking 100 user1 200 user2  # 添加带分数的元素
ZRANGE ranking 0 10 WITHSCORES     # 按分数排序获取
```
- 应用：排行榜、延时队列

**6. Bitmap（位图）**：
```redis
SETBIT online_users 1001 1    # 设置用户1001在线
GETBIT online_users 1001      # 检查用户是否在线
BITCOUNT online_users         # 统计在线用户数
```
- 应用：用户在线状态、布隆过滤器

**7. HyperLogLog（基数统计）**：
```redis
PFADD uv user1 user2 user3    # 添加用户
PFCOUNT uv                    # 统计独立用户数
```
- 应用：UV统计、大数据去重计数

## redis列表底层数据结构是什么？标记

1.  **早期版本**：在早期版本中，List可能同时使用 `ziplist` (压缩列表) 和 `linkedlist` (双向链表)。`ziplist` 用于元素较少、体积较小的情况以节省内存；元素多或体积大时则用 `linkedlist` 以保证操作效率。
2.  **Quicklist (Redis 3.2+ )**：后来引入了 `quicklist` 作为List的底层实现。`quicklist` 本质上是一个由 `ziplist`（或 `listpack` 在更新版本中）组成的双向链表。它试图结合 `ziplist` 的空间效率和 `linkedlist` 的时间效率。
3.  **Listpack (Redis 7.0+)**: `listpack` 是 `ziplist` 的一种更优化的替代方案，用于 `quicklist` 的节点。
简单来说：“Redis的List底层为了平衡空间和时间效率，采用了像quicklist这样的复合结构，它是由多个小的压缩块（如ziplist或listpack）链接而成的。”

**QuickList结构**：
```
quicklist
├── quicklistNode1 → ziplist[e1,e2,e3]
├── quicklistNode2 → ziplist[e4,e5,e6]  
└── quicklistNode3 → ziplist[e7,e8,e9]
```

**设计思想**：
- **ziplist**: 内存紧凑，但插入删除慢O(n),*ziplist是一种专门设计用来紧凑存储不同长度、不同类型元素的特殊“压缩数组”，更省空间，更灵活*
- **linkedlist**: 插入删除快O(1)，但内存碎片多,*双向链表*
- **quicklist**: 综合两者优势，分段存储，*结合了ziplist的紧凑性和linkedlist的快速插入删除，每个节点是ziplist，节点之间是linkedlist*

**配置参数**：
```
list-max-ziplist-size 8     # 每个节点最大元素数
list-compress-depth 2       # 压缩深度，中间节点压缩
```

**优化效果**：
- 内存使用减少约20%
- 支持LZ4压缩
- 保持O(1)头尾操作性能

## redis的哈希类型的结构是什么？
跳表
哈希表

*   **Hash类型底层**：当Hash对象中的元素数量较少且元素值较短时，Redis会使用 `ziplist` (压缩列表) 来存储，以节省内存。当元素数量或大小超过一定阈值时，则会转换为标准的 `hashtable` (字典) 结构。
*   **跳表 (Skiplist)**：跳表在Redis中主要用于 **ZSet (有序集合)** 类型的底层实现，ZSet 同时使用 `hashtable` 和 `skiplist` 来保证快速查找和范围查询。
所以，对于Hash类型，主要是 `ziplist` 和 `hashtable`。

### Redis Hash底层实现
**实际结构**：Redis Hash使用的是**hashtable**，不是跳表！

**Hash底层实现**：
1. **ziplist**（元素少时）：
   - 条件：元素个数 ≤ 512 且 单个值长度 ≤ 64字节
   - 优点：内存紧凑，cache friendly
   
2. **hashtable**（元素多时）：
   - 结构：数组 + 链表解决冲突
   - 扩容：渐进式rehash，避免阻塞

**跳表(skiplist)实际用于**：
- **ZSet（有序集合）**: 同时使用hashtable + skiplist
  - hashtable：O(1)查找元素
  - skiplist：O(logN)范围查询和排序

**Hash操作复杂度**：
```redis
HSET user:1 name "张三"    # O(1)
HGET user:1 name          # O(1)  
HGETALL user:1            # O(n) n为字段数
```

**内存优化**：
```
# 配置阈值
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
```

## redis的删除策略有哪些？
懒删除
随机删除
混合删除？

**1. 过期键删除策略** (针对已设置过期时间的key)：
    *   **惰性删除 (Lazy Expiration)**：当客户端访问一个key时，Redis会检查该key是否已过期，如果过期则删除。优点是CPU友好，缺点是可能导致已过期的key长时间占用内存。  
    *   **定期删除 (Active Expiration)**：Redis会定期（默认每秒10次，可配置）随机抽取一部分设置了过期时间的key进行检查，并删除其中已过期的key。这是一个折中方案。  

**2. 内存淘汰策略 (Eviction Policies)** (当内存使用达到 `maxmemory` 限制时触发，用来删除某些key以腾出空间，不仅仅是过期的key)：
    *   `noeviction`: 不删除任何key，新写入操作会报错（默认策略）。  
    *   `allkeys-lru`: 从所有key中移除最近最少使用的key。  
    *   `volatile-lru`: 从设置了过期时间的key中移除最近最少使用的key。  
    *   `allkeys-random`: 从所有key中随机移除一个key。  
    *   `volatile-random`: 从设置了过期时间的key中随机移除一个key。  
    *   `volatile-ttl`: 从设置了过期时间的key中移除剩余生存时间最短的key。  
    *   `allkeys-lfu` (Redis 4.0+): 从所有key中移除最不经常使用的key。  
    *   `volatile-lfu` (Redis 4.0+): 从设置了过期时间的key中移除最不经常使用的key。  
“随机删除”可以理解为定期删除中的采样方式，或者是内存淘汰策略中的一种。 “混合删除”可以理解为惰性删除和定期删除的结合使用。

### Redis过期删除策略
**1. 惰性删除(Lazy Expiration)**：
- **时机**: 访问key时检查是否过期
- **优点**: CPU开销小，只有访问时才删除
- **缺点**: 内存占用高，过期key可能长期占用内存

**2. 定期删除(Active Expiration)**：
- **时机**: 定期扫描一部分key检查过期
- **频率**: 默认每100ms执行一次
- **策略**: 随机采样20个key，删除过期的，如果过期比例>25%继续采样

**3. 内存淘汰策略(Eviction)**：
当内存不足时触发：
```
# 针对设置过期时间的key
allkeys-lru      # 删除最少使用的key
allkeys-lfu      # 删除最少频率使用的key  
allkeys-random   # 随机删除key

# 针对设置过期时间的key
volatile-lru     # 删除过期key中最少使用的
volatile-lfu     # 删除过期key中最少频率使用的
volatile-random  # 随机删除过期key
volatile-ttl     # 删除即将过期的key

# 其他策略
noeviction      # 不删除，写入报错
```

**最佳实践**：
- 设置合理的`maxmemory`
- 选择合适的淘汰策略（推荐allkeys-lru）
- 监控内存使用和命中率

## redis的分布式锁是什么？
set key nx
利用redis+lua脚本的原子性，
key为锁，value为解锁的关键，符合才能解锁；

1.  **基本原理**：利用Redis的 `SET key value NX EX seconds` (或 `PX milliseconds`) 命令。`NX` 保证只有key不存在时才设置成功（原子性加锁），`EX/PX` 设置过期时间，防止因客户端崩溃导致死锁。`value` 通常是一个唯一的客户端标识（如UUID），用于安全解锁。
2.  **解锁原子性**：解锁时，需要先 `GET` 锁的value，判断是否与自己加锁时设置的value一致，如果一致再 `DEL` key。这个“判断再删除”的操作不是原子的，所以通常使用Lua脚本来保证原子性，防止误删其他客户端的锁。
3.  **可重入性（可选）**：如果需要可重入锁，可以在value中存储锁的持有者和重入次数，或者使用Redis Hash结构。
4.  **锁续期（可选，如Redisson）**：对于长时间任务，可能需要在锁过期前自动续期（“看门狗”机制）。
5.  **更复杂的场景（可选，如RedLock）**：在多主Redis集群中，为了更高的可用性，可能会提到RedLock算法，但它也有争议。
主要讲清楚前两点（原子加锁、原子解锁、过期时间）就很好了。

### Redis分布式锁详解
**基础实现**：
```redis
# 加锁：设置key，值为客户端ID，过期时间防止死锁
SET lock_key client_id NX EX 30

# 解锁：Lua脚本保证原子性
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
```
