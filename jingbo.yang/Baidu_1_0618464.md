- [百度golang开发实习生一面](#百度golang开发实习生一面)
  - [算法 排列组合总和 lc081](#算法-排列组合总和-lc081)
  - [说说进程和线程的区别](#说说进程和线程的区别)
  - [多进程多线程编程需要注意哪些方面？](#多进程多线程编程需要注意哪些方面)
  - [说说什么是条件变量？如何使用(golang,c++)？](#说说什么是条件变量如何使用golangc)
  - [对IO多路复用的理解](#对io多路复用的理解)
  - [select、poll、epoll的区别](#selectpollepoll的区别)
  - [在浏览器中输入URL到显示html页面的过程](#在浏览器中输入url到显示html页面的过程)
    - [补充](#补充)
  - [HTTPS连接建立的正确顺序](#https连接建立的正确顺序)
  - [get和post的区别](#get和post的区别)
  - [什么是mysql事务](#什么是mysql事务)
  - [MySQL索引在什么情况下会失效？](#mysql索引在什么情况下会失效)
  - [说说你了解的查询优化策略？](#说说你了解的查询优化策略)
  - [redis有哪些数据结构？](#redis有哪些数据结构)
  - [说说你怎么使用redis的？](#说说你怎么使用redis的)
  - [1. 两类缓冲区怎么工作？](#1-两类缓冲区怎么工作)
  - [2. 大小能调吗？](#2-大小能调吗)
  - [3. buffer ≠ backlog / 滑动窗口](#3-buffer--backlog--滑动窗口)
  - [4. 为什么要有这两个缓冲区？](#4-为什么要有这两个缓冲区)
    - [结论](#结论)

# 百度golang开发实习生一面
面试时长1h
自我介绍
## 算法 排列组合总和 lc081
## 说说进程和线程的区别
进程是操作系统最小的资源分配单位，资源包括内存资源，文件描述符等。  
线程是进程的一个执行单元，线程之间共享进程的资源。线程是操作系统最小的调度单位。  
*线程共享 虚拟地址空间、文件描述符、信号量等资源，但拥有独立的 栈 和寄存器上下文*

## 多进程多线程编程需要注意哪些方面？
1. 资源共享与通信：多进程之间的通信相对复杂，通常需要使用IPC机制（如socket、管道、消息队列、共享内存等）；而多线程之间可以通过共享内存直接通信，但需要注意同步问题。

| 分类              | 说明          |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| **匿名管道 pipe()** | 由 `pipe()` 系统调用创建，生成一对**文件描述符**：读端 `fd[0]`、写端 `fd[1]`。<br>• **半双工**：数据只能单向流动（父→子或子→父）。<br>• **亲缘限制**：只能在**具有亲缘关系**的进程间传递（通常是 `fork` 之后）。 |
| **命名管道 FIFO**   | 由 `mkfifo()` 或 shell 命令 `mkfifo` 创建，表现为一个特殊文件节点。<br>• 任何进程只要能访问这个节点就能读/写，实现**不具亲缘关系**进程通信。<br>• 仍然是**半双工**（读写方向需再开一个 FIFO 才能双向）。         |
| **特点**          | - 内核缓冲区实现，数据先进先出，字节流式。<br>- 简单、开销小、不涉及网络栈。<br>- 仅限**同一主机**内核空间；跨主机时无法使用。                                                                 |


| 分类                                 | 说明                                                                                                                     |
| ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| **UNIX 域套接字 (AF\_UNIX/AF\_LOCAL)** | 文件系统路径作为“地址”。仅在**同一主机**进程间通信，但走 socket API，性能好于 TCP，功能与网络套接字一致（全双工、支持 `sendmsg`/`recvmsg` 传递文件描述符等）。                   |
| **网络套接字 (AF\_INET/AF\_INET6 …)**   | 使用 IP+端口，既可**本机 IPC**，也可**跨主机**。可选 TCP（面向连接、可靠字节流）或 UDP（无连接、数据报）。                                                      |
| **特点**                             | - **全双工**，读写独立。<br>- 支持面向连接或无连接模式、流/报文两种抽象。<br>- 没有亲缘关系限制，可跨主机、跨语言。<br>- 功能丰富：带外数据、异步 I/O、IO 多路复用（select/poll/epoll）等。 |

[socket读写缓冲区](#socket)


1. 线程安全：在多线程环境下，访问共享资源时需要考虑线程安全问题，避免数据竞争和不一致性(死锁？？)。如何避免死锁？总结一下
   - 使用锁（如互斥锁、读写锁）来保护共享资源。
   - 避免嵌套锁：尽量避免在持有一个锁的情况下去获取另一个锁。
   - 使用超时机制：在获取锁时设置超时时间，防止死锁。
   - 资源分配顺序：确保所有线程按照相同的顺序请求资源，以避免循环等待。


> 死锁条件：互斥，持有等待，不可剥夺，循环等待(线程 A 持有锁 1 等锁 2，线程 B 持有锁 2 等锁 1)。
1. 性能开销：创建和切换线程的开销相对较小，但过多的线程会导致上下文切换频繁，从而影响性能；而多进程的开销相对较大，但可以充分利用多核CPU的优势。
2. 错误处理：多进程中的一个进程崩溃不会影响其他进程，而多线程中的一个线程崩溃可能导致整个进程崩溃。错误处理是指try catch异常处理，panic recover？？

## 说说什么是条件变量？如何使用(golang,c++)？
条件变量是一种同步原语，用于在多线程环境中实现线程间的等待和通知机制。它允许一个或多个线程等待某个条件的发生，并在条件满足时被唤醒。  
信号量是条件变量的一种实现方式，通常与互斥锁一起使用。  
pv操作是信号量的基本操作，P操作（wait）用于请求资源，V操作（signal）用于释放资源。  
*条件变量 = 等待/通知机制，依赖互斥锁；信号量 = 计数资源，可独立于互斥锁存在。*  
银行家算法是一种资源分配和死锁避免算法，它通过检查资源分配是否安全来决定是否允许进程请求资源。  
哲学家就餐问题是一个经典的同步问题，涉及多个线程（哲学家）共享有限资源（叉子），需要通过条件变量和互斥锁来解决。  

## 对IO多路复用的理解
io多路复用是让**单个进程或者线程同时处理多个IO操作的技术**。它通过监听多个文件描述符（如socket、管道等），当其中一个或多个文件描述符就绪时，通知应用程序进行相应的处理，从而提高了资源利用率和响应速度。可以**实现非阻塞IO操作，避免了传统的阻塞IO模型中每个连接都需要一个线程或进程的开销**。

## select、poll、epoll的区别
1. select：使用一个数组来监听多个文件描述符，当其中一个或多个就绪时，返回就绪的文件描述符集合。select的缺点是每次调用都需要遍历所有文件描述符，效率较低。  
2. poll：类似于select，但使用链表来存储文件描述符，避免了select的数组大小限制。poll的缺点是每次调用仍然需要遍历所有文件描述符。  

3. epoll：Linux特有的IO多路复用机制，使用事件驱动模型，支持边缘触发和水平触发。epoll通过内核维护一个红黑树来存储文件描述符(epoll 内部 红黑树保存监控 FD + 就绪链表 O(1) 取出)  

## 在浏览器中输入URL到显示html页面的过程
1. URL解析与导航初始化  
URL解析：浏览器解析URL结构（协议、域名、端口、路径、查询参数等）  
检查HSTS列表：确认是否需要将HTTP请求升级为HTTPS  
处理特殊URL：如data:URL、file:URL等特殊协议处理  
检查缓存：浏览器检查是否有本地缓存可用  
检查内存缓存(Memory Cache)  
检查磁盘缓存(Disk Cache)  
应用缓存策略(Cache-Control, ETag, Last-Modified等)  
2. DNS解析过程  
DNS查找顺序：  
浏览器DNS缓存  
操作系统DNS缓存  
读取本地hosts文件  
向本地DNS服务器查询(通常是路由器或ISP提供)  
递归查询:  
根域名服务器   
顶级域名服务器(TLD)  
权威DNS服务器  
DNS优化：  
DNS预取(dns-prefetch)  
可能的DNS-over-HTTPS/DNS-over-TLS  
解析结果：获得目标服务器IP地址  
3. 网络连接建立  
TCP连接建立 (三次握手):  

         客户端发送SYN包(序列号x)  
         服务器返回SYN-ACK包(序列号y, 确认号x+1)  
         客户端发送ACK包(确认号y+1)  

HTTPS特有步骤 - TLS/SSL握手:

         Client Hello: 客户端发送支持的加密套件和随机数  
         Server Hello: 服务器选择加密套件并发送证书和随机数  
         证书验证: 客户端验证服务器证书的有效性  
         密钥交换: 协商会话密钥(如使用RSA或DH/ECDHE)  
         完成握手: 验证握手消息并开始加密通信  

4. HTTP交互过程
HTTP请求准备：

         构造HTTP请求头(User-Agent, Accept, Cookie等)
         添加请求主体(如果是POST请求)
         应用同源策略检查
         HTTP请求发送：

         请求行(方法、路径、HTTP版本)
         请求头
         请求体(如适用)
         服务器端处理：

         接收请求
         路由到正确的处理程序
         应用程序处理(业务逻辑)
         数据库操作(如需要)
         生成HTTP响应
         HTTP响应返回：

         状态行(HTTP版本、状态码、状态消息)
         响应头
         响应体(HTML内容等)

5. 浏览器渲染过程

### 补充
HTTPS连接的建立过程确实是"先建立TCP连接，然后进行TLS/SSL握手"：

## HTTPS连接建立的正确顺序

1. **TCP连接建立** (三次握手)
   ```
   客户端 -----SYN-----> 服务器
   客户端 <--SYN+ACK---- 服务器
   客户端 -----ACK-----> 服务器
   ```
   此时已建立了一个可靠的、双向的TCP连接

2. **在已建立的TCP连接上进行TLS握手**
   ```
   客户端 ---Client Hello---> 服务器  (提供支持的加密套件、随机数等)
   客户端 <--Server Hello---- 服务器  (选择加密套件、发送证书、随机数)
   客户端 ---密钥交换-------> 服务器  (验证证书后交换会话密钥信息)
   客户端 <--握手完成-------- 服务器  (确认加密通信准备就绪)
   ```

3. **在加密通道上传输HTTP消息**
   ```
   客户端 ---加密的HTTP请求---> 服务器
   客户端 <--加密的HTTP响应--- 服务器
   ```

HTTPS是HTTP over TLS/SSL，其中:
- TCP位于传输层，提供可靠连接
- TLS/SSL位于会话层，提供安全加密
- HTTP位于应用层，处理实际内容请求/响应

因此，网络协议栈自底向上的顺序是：TCP → TLS → HTTP，连接建立也必须按照这个顺序进行。

## get和post的区别
1. **数据传输方式**：GET请求通过URL传递参数，参数在URL中可见；POST请求通过请求体传递参数，参数在URL中不可见。
2. **数据长度限制**：GET请求的URL长度有限制（通常为2048个字符），而POST请求没有严格的长度限制，可以传输较大的数据量。
3. **安全性**：GET请求的参数在URL中可见，容易被缓存和记录，不适合传输敏感数据；POST请求的参数在请求体中，不易被缓存和记录，适合传输敏感数据。
4. **幂等性**：GET请求是幂等的，即多次请求同一资源不会改变服务器状态；POST请求不是幂等的，多次请求可能会导致服务器状态变化（如创建多个资源）(但是可以通过实现生成的幂等标识符实现幂等)。
5. **缓存**：GET请求可以被浏览器缓存，而POST请求通常不会被缓存。

## 什么是mysql事务
将一系列数据库操作封装在一个事务中，确保这些操作要么全部成功，要么全部失败。事务具有四个特性（ACID）：
1. **原子性（Atomicity）**：事务中的所有操作要么全部执行成功，要么全部不执行。
2. **一致性（Consistency）**：事务执行前后，数据库状态保持一致。
3. **隔离性（Isolation）**：多个事务并发执行时，互不干扰，每个事务的执行结果对其他事务是不可见的，直到提交。
4. **持久性（Durability）**：一旦事务提交，其结果是永久性的，即使系统崩溃也不会丢失。  

*BEGIN / COMMIT / ROLLBACK 只是 SQL-level 控制；InnoDB 内部用 redo log (WAL) 和 undo log 保证持久性与原子性*

## MySQL索引在什么情况下会失效？
1. **全表扫描**：当查询条件不使用索引列，或者使用了不等于（<>）、IS NULL等条件时，可能导致全表扫描。
2. **复杂查询**：在JOIN、子查询等复杂查询中，可能因为优化器选择了不使用索引的执行计划而导致索引失效。
3. **数据类型不匹配**：查询条件中的数据类型与索引列的数据类型不匹配时，可能导致索引失效。
4. **函数操作**：在查询条件中对索引列使用函数（如DATE()、LOWER()等）时，可能导致索引失效。
5. **模糊查询**：LIKE '%keyword%'形式的模糊查询无法使用索引，可能导致全表扫描。破坏最左匹配原则。
6. 补充：隐式类型转换、列上使用函数 / 运算、范围条件后再带索引列（>、<、BETWEEN 破坏最左匹配）

## 说说你了解的查询优化策略？
选择合适的索引：根据查询条件选择区分度大的索引，以提高查询效率。
使用覆盖索引：如果查询只涉及索引列，可以使用覆盖索引，避免回表操作。
避免全表扫描：通过合理的查询条件和索引设计，避免全表扫描，提高查询效率。  
使用EXPLAIN分析查询计划：通过EXPLAIN命令查看查询执行计划，分析是否使用了索引，是否存在全表扫描等问题。  
合理使用JOIN：在多表查询中，选择合适的JOIN类型（如INNER JOIN、LEFT JOIN等），并确保JOIN条件使用索引列。  
避免使用SELECT *：只查询需要的列，减少数据传输量，提高查询效率。
使用LIMIT限制结果集：在查询结果较大时，使用LIMIT限制返回的行数，减少数据处理量。  
补充：  
合理分区 / 分表（大表优化）。  
使用 SQL_HINT / 强制索引 调整执行计划。  
常考 “如何定位慢查询”：slow_query_log + pt-query-digest(分析工具)。  

## redis有哪些数据结构？
string
list
set
zset
hash
bitmap

## 说说你怎么使用redis的？
分布式锁(SET NX + EX + 唯一标识 + Lua 原子释放)
数据缓存
计数器 incr decr
排行榜 zset
布隆过滤器 bloom filter
存储轻量关系不强、访问频繁的结构化对象，避免落库



关于MySQL索引失效的情况

原文错误：全表扫描：当查询条件不使用索引列，或者使用了不等于（<>）、IS NULL等条件时，可能导致全表扫描。
更正：在索引列上使用 IS NULL 条件可以利用索引，并不会必然导致索引失效或全表扫描。而使用不等于（如 <> 或 !=）通常会导致索引失效。

<h1 id="socket">socket是具有读写缓冲区吗？</h1>

**有**。内核为每一个套接字都维护了两块独立的**发送缓冲区（send buffer）**和**接收缓冲区（receive buffer）**。它们位于内核态内存，用来暂存应用层写入但尚未发出的数据，或网络到达但应用层尚未读取的数据。([Stack Overflow][1], [man7.org][2])

---

## 1. 两类缓冲区怎么工作？

| 缓冲区                   | 典型调用                                             | 作用机理                                                                                          |
| --------------------- | ------------------------------------------------ | --------------------------------------------------------------------------------------------- |
| **发送缓冲区**（SO\_SNDBUF） | `send()/write()`<br>`setsockopt(..., SO_SNDBUF)` | - 应用把字节拷进该缓冲区即算“写成功”，随后由协议栈异步发送。<br>- **满了**时：<br> • 阻塞套接字会被挂起直到有空间；<br> • 非阻塞套接字返回 `EAGAIN`。 |
| **接收缓冲区**（SO\_RCVBUF） | `recv()/read()`<br>`setsockopt(..., SO_RCVBUF)`  | - 数据包到达后先进入该缓冲区；应用随后读取。<br>- **空了**时：<br> • 阻塞读会睡眠；<br> • 非阻塞读返回 `EAGAIN`。                    |

> 对 **TCP** 而言，接收缓冲区大小还决定 **接收窗口**，直接影响对端的发送速率；缓冲区填满时，窗口降到 0，对端停止发送。([Medium][3])
> 对 **UDP**，如果接收缓冲区满，新到的数据报将被直接丢弃。([Stack Overflow][1])

---

## 2. 大小能调吗？

* 通过 `setsockopt(fd, SOL_SOCKET, SO_SNDBUF, …)` 和 `SO_RCVBUF` 调整。
* Linux 会将你设置的值 **翻倍**（用于协议栈开销），`getsockopt` 读出的也是翻倍后的数。默认值和上限由 `/proc/sys/net/core/{rmem,sndmem}_*` 控制。([man7.org][2])

---

## 3. buffer ≠ backlog / 滑动窗口

* **backlog**：仅在 `listen()` 端口上存在，是“尚未 `accept` 的已完成握手队列”，并非数据缓存。
* **滑动窗口**：TCP 头里的通告窗口 = 接收缓冲区可用空间，属于协议层的流量控制概念；缓冲区是实现它的物理存储。

---

## 4. 为什么要有这两个缓冲区？

1. **解耦应用与网络速度**：应用写完即可返回，不必等包真正发出去；网络抖动也不会立即饿死读端。
2. **拥塞/流控**：TCP 可以根据缓冲区余量动态调整窗口，避免丢包。
3. **系统调用降频**：一次写入/读取大块数据，减少用户态与内核态切换。

---

### 结论

> 每个 socket 在内核中都拥有独立的发送和接收缓冲区，大小可调，可被阻塞/非阻塞语义和 TCP/UDP 协议栈差异化利用；这与应用层自行维护的用户态缓冲区是两回事，也与 pipe 的单向缓冲区机制类似但实现细节不同。
