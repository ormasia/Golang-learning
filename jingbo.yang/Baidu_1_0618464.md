# 百度golang开发实习生一面
面试时长1h
自我介绍
## 算法 排列组合总和 lc081
## 说说进程和线程的区别
进程是操作系统最小的资源分配单位，资源包括内存资源，文件描述符等。线程是进程的一个执行单元，线程之间共享进程的资源。线程是操作系统最小的调度单位。
## 多进程多线程编程需要注意哪些方面？
1. 资源共享与通信：多进程之间的通信相对复杂，通常需要使用IPC机制（如管道、消息队列、共享内存等）；而多线程之间可以通过共享内存直接通信，但需要注意同步问题。
2. 线程安全：在多线程环境下，访问共享资源时需要考虑线程安全问题，避免数据竞争和不一致性(死锁？？)。如何避免死锁？总结一下
   - 使用锁（如互斥锁、读写锁）来保护共享资源。
   - 避免嵌套锁：尽量避免在持有一个锁的情况下去获取另一个锁。
   - 使用超时机制：在获取锁时设置超时时间，防止死锁。
   - 资源分配顺序：确保所有线程按照相同的顺序请求资源，以避免循环等待。
3. 性能开销：创建和切换线程的开销相对较小，但过多的线程会导致上下文切换频繁，从而影响性能；而多进程的开销相对较大，但可以充分利用多核CPU的优势。
4. 错误处理：多进程中的一个进程崩溃不会影响其他进程，而多线程中的一个线程崩溃可能导致整个进程崩溃。错误处理是指try catch异常处理，panic recover？？

## 说说什么是条件变量？如何使用(golang,c++)？
条件变量是一种同步原语，用于在多线程环境中实现线程间的等待和通知机制。它允许一个或多个线程等待某个条件的发生，并在条件满足时被唤醒。
信号量是条件变量的一种实现方式，通常与互斥锁一起使用。
pv操作是信号量的基本操作，P操作（wait）用于请求资源，V操作（signal）用于释放资源。
银行家算法是一种资源分配和死锁避免算法，它通过检查资源分配是否安全来决定是否允许进程请求资源。
哲学家就餐问题是一个经典的同步问题，涉及多个线程（哲学家）共享有限资源（叉子），需要通过条件变量和互斥锁来解决。

## 对IO多路复用的理解
io多路复用是让**单个进程或者线程同时处理多个IO操作的技术**。它通过监听多个文件描述符（如socket、管道等），当其中一个或多个文件描述符就绪时，通知应用程序进行相应的处理，从而提高了资源利用率和响应速度。可以**实现非阻塞IO操作，避免了传统的阻塞IO模型中每个连接都需要一个线程或进程的开销**。

## select、poll、epoll的区别
1. select：使用一个数组来监听多个文件描述符，当其中一个或多个就绪时，返回就绪的文件描述符集合。select的缺点是每次调用都需要遍历所有文件描述符，效率较低。
2. poll：类似于select，但使用链表来存储文件描述符，避免了select的数组大小限制。poll的缺点是每次调用仍然需要遍历所有文件描述符。
3. epoll：Linux特有的IO多路复用机制，使用事件驱动模型，支持边缘触发和水平触发。epoll通过内核维护一个红黑树来存储文件描述符，效率更高，适用于大量并发连接的场景。

## 在浏览器中输入URL到显示html页面的过程
1. URL解析与导航初始化
URL解析：浏览器解析URL结构（协议、域名、端口、路径、查询参数等）
检查HSTS列表：确认是否需要将HTTP请求升级为HTTPS
处理特殊URL：如data:URL、file:URL等特殊协议处理
检查缓存：浏览器检查是否有本地缓存可用
检查内存缓存(Memory Cache)
检查磁盘缓存(Disk Cache)
应用缓存策略(Cache-Control, ETag, Last-Modified等)
2. DNS解析过程
DNS查找顺序：
浏览器DNS缓存
操作系统DNS缓存
读取本地hosts文件
向本地DNS服务器查询(通常是路由器或ISP提供)
递归查询:
根域名服务器
顶级域名服务器(TLD)
权威DNS服务器
DNS优化：
DNS预取(dns-prefetch)
可能的DNS-over-HTTPS/DNS-over-TLS
解析结果：获得目标服务器IP地址
3. 网络连接建立
TCP连接建立 (三次握手):

客户端发送SYN包(序列号x)
服务器返回SYN-ACK包(序列号y, 确认号x+1)
客户端发送ACK包(确认号y+1)
HTTPS特有步骤 - TLS/SSL握手:

Client Hello: 客户端发送支持的加密套件和随机数
Server Hello: 服务器选择加密套件并发送证书和随机数
证书验证: 客户端验证服务器证书的有效性
密钥交换: 协商会话密钥(如使用RSA或DH/ECDHE)
完成握手: 验证握手消息并开始加密通信
4. HTTP交互过程
HTTP请求准备：

构造HTTP请求头(User-Agent, Accept, Cookie等)
添加请求主体(如果是POST请求)
应用同源策略检查
HTTP请求发送：

请求行(方法、路径、HTTP版本)
请求头
请求体(如适用)
服务器端处理：

接收请求
路由到正确的处理程序
应用程序处理(业务逻辑)
数据库操作(如需要)
生成HTTP响应
HTTP响应返回：

状态行(HTTP版本、状态码、状态消息)
响应头
响应体(HTML内容等)
5. 浏览器渲染过程

### 补充
是的，您的理解是正确的。HTTPS连接的建立过程确实是"先建立TCP连接，然后进行TLS/SSL握手"：

## HTTPS连接建立的正确顺序

1. **TCP连接建立** (三次握手)
   ```
   客户端 -----SYN-----> 服务器
   客户端 <--SYN+ACK---- 服务器
   客户端 -----ACK-----> 服务器
   ```
   此时已建立了一个可靠的、双向的TCP连接

2. **在已建立的TCP连接上进行TLS握手**
   ```
   客户端 ---Client Hello---> 服务器  (提供支持的加密套件、随机数等)
   客户端 <--Server Hello---- 服务器  (选择加密套件、发送证书、随机数)
   客户端 ---密钥交换-------> 服务器  (验证证书后交换会话密钥信息)
   客户端 <--握手完成-------- 服务器  (确认加密通信准备就绪)
   ```

3. **在加密通道上传输HTTP消息**
   ```
   客户端 ---加密的HTTP请求---> 服务器
   客户端 <--加密的HTTP响应--- 服务器
   ```

HTTPS是HTTP over TLS/SSL，其中:
- TCP位于传输层，提供可靠连接
- TLS/SSL位于会话层，提供安全加密
- HTTP位于应用层，处理实际内容请求/响应

因此，网络协议栈自底向上的顺序是：TCP → TLS → HTTP，连接建立也必须按照这个顺序进行。

## get和post的区别
1. **数据传输方式**：GET请求通过URL传递参数，参数在URL中可见；POST请求通过请求体传递参数，参数在URL中不可见。
2. **数据长度限制**：GET请求的URL长度有限制（通常为2048个字符），而POST请求没有严格的长度限制，可以传输较大的数据量。
3. **安全性**：GET请求的参数在URL中可见，容易被缓存和记录，不适合传输敏感数据；POST请求的参数在请求体中，不易被缓存和记录，适合传输敏感数据。
4. **幂等性**：GET请求是幂等的，即多次请求同一资源不会改变服务器状态；POST请求不是幂等的，多次请求可能会导致服务器状态变化（如创建多个资源）。
5. **缓存**：GET请求可以被浏览器缓存，而POST请求通常不会被缓存。

## 什么是mysql事务
将一系列数据库操作封装在一个事务中，确保这些操作要么全部成功，要么全部失败。事务具有四个特性（ACID）：
1. **原子性（Atomicity）**：事务中的所有操作要么全部执行成功，要么全部不执行。
2. **一致性（Consistency）**：事务执行前后，数据库状态保持一致。
3. **隔离性（Isolation）**：多个事务并发执行时，互不干扰，每个事务的执行结果对其他事务是不可见的，直到提交。
4. **持久性（Durability）**：一旦事务提交，其结果是永久性的，即使系统崩溃也不会丢失。  
事务通常通过BEGIN、COMMIT和ROLLBACK语句来控制

## MySQL索引在什么情况下会失效？
1. **全表扫描**：当查询条件不使用索引列，或者使用了不等于（<>）、IS NULL等条件时，可能导致全表扫描。
2. **复杂查询**：在JOIN、子查询等复杂查询中，可能因为优化器选择了不使用索引的执行计划而导致索引失效。
3. **数据类型不匹配**：查询条件中的数据类型与索引列的数据类型不匹配时，可能导致索引失效。
4. **函数操作**：在查询条件中对索引列使用函数（如DATE()、LOWER()等）时，可能导致索引失效。
5. **模糊查询**：LIKE '%keyword%'形式的模糊查询无法使用索引，可能导致全表扫描。破坏最左匹配原则。

## 说说你了解的查询优化策略？
选择合适的索引：根据查询条件选择区分度大的索引，以提高查询效率。
使用覆盖索引：如果查询只涉及索引列，可以使用覆盖索引，避免回表操作。
避免全表扫描：通过合理的查询条件和索引设计，避免全表扫描，提高查询效率。
使用EXPLAIN分析查询计划：通过EXPLAIN命令查看查询执行计划，分析是否使用了索引，是否存在全表扫描等问题。
合理使用JOIN：在多表查询中，选择合适的JOIN类型（如INNER JOIN、LEFT JOIN等），并确保JOIN条件使用索引列。
避免使用SELECT *：只查询需要的列，减少数据传输量，提高查询效率。
使用LIMIT限制结果集：在查询结果较大时，使用LIMIT限制返回的行数，减少数据处理量。

## redis有哪些数据结构？
string
list
set
zset
hash
bitmap

## 说说你怎么使用redis的？
分布式锁
数据缓存
计数器 incr decr
排行榜 zset
布隆过滤器 bloom filter
存储非关系型数据？？可以吗？这么做？？

  
关于条件变量和信号量的关系

原文错误：信号量是条件变量的一种实现方式，通常与互斥锁一起使用。
更正：条件变量和信号量是两种不同的同步原语。它们之间没有直接的实现关系，而是用于解决不同类型的同步问题。条件变量用于基于特定“条件”的等待和通知，而信号量用于控制对有限资源的并发访问数量。


关于MySQL索引失效的情况

原文错误：全表扫描：当查询条件不使用索引列，或者使用了不等于（<>）、IS NULL等条件时，可能导致全表扫描。
更正：在索引列上使用 IS NULL 条件可以利用索引，并不会必然导致索引失效或全表扫描。而使用不等于（如 <> 或 !=）通常会导致索引失效。