- [cdg后台开发，二面](#cdg后台开发二面)
  - [Reactor和Proactor的区别](#reactor和proactor的区别)
  - [批处理是什么？](#批处理是什么)
    - [以 CPU 指令流水线为例：直观理解时间重叠效应](#以-cpu-指令流水线为例直观理解时间重叠效应)
  - [预热机制是什么？](#预热机制是什么)
  - [ipconfig有什么用？](#ipconfig有什么用)
  - [mysql和redis的数据一致性](#mysql和redis的数据一致性)
  - [mysql备份](#mysql备份)
  - [详细说说binlog作用的流程？](#详细说说binlog作用的流程)
    - [STATEMENT 格式](#statement-格式)
    - [ROW 格式](#row-格式)

# cdg后台开发，二面

算法：零钱兑换 项目拷打：rpc和im 轮子项目；

## Reactor和Proactor的区别

**Reactor模式（同步非阻塞IO）**：
- 应用程序负责实际的IO操作（read/write）
- 内核只负责通知哪些文件描述符就绪（可读/可写）
- 流程：注册事件 → 等待通知 → 应用程序执行IO → 处理数据
- 代表：Linux的epoll、BSD的kqueue

**Proactor模式（异步IO）**：
- 内核负责完成实际的IO操作
- 应用程序只需处理IO操作的结果
- 流程：发起异步IO请求 → 内核执行IO → 通知完成 → 处理结果
- 代表：Windows的IOCP、Linux的io_uring（部分支持）

**核心区别**：
- Reactor：应用程序主动执行IO操作
- Proactor：内核主动完成IO操作，应用程序被动接收结果

其他补充

Linux下真正的异步IO（AIO）支持有限，大多数高性能服务器仍使用Reactor模式
Go语言的runtime也是基于类似Reactor的模式实现的

## 批处理是什么？

- 数据库操作：批量插入、更新多条记录
- 消息处理：攒批发送消息，减少网络开销
- 日志处理：批量写入日志文件
- 缓存操作：Redis pipeline批量执行命令

### 以 CPU 指令流水线为例：直观理解时间重叠效应
  CPU 指令执行分为 5 阶段：取指（Fetch）→ 解码（Decode）→ 执行（Execute）→ 访存（Memory）→ 写回（Writeback）

串行执行（非流水线）：
任务1: F1 → D1 → E1 → M1 → W1 （总耗时5周期）  
任务2: F2 → D2 → E2 → M2 → W2 （任务2需等任务1完成后开始，总耗时10周期）

流水线执行：
```
周期1: F1
周期2: D1 → F2
周期3: E1 → D2 → F3
周期4: M1 → E2 → D3 → F4
周期5: W1 → M2 → E3 → D4 → F5
```
任务1完成于周期5，任务2完成于周期6，任务3完成于周期7，平均每个任务耗时约1周期。

关键：流水线让 5 个阶段像 “传送带” 一样持续运转，每个周期都有任务在不同阶段被处理，CPU 利用率从 20%（串行）提升至接近 100%。

## 预热机制是什么？

数据提前加载到缓存中
将静态数据放在CDN中
将文件数据提前加载到内存中

缓存预热：启动时将热点数据加载到Redis/内存缓存
JVM预热：Java应用启动后执行一些操作触发JIT编译
连接池预热：提前建立数据库连接
CDN预热：将静态资源推送到边缘节点
操作系统预热：将关键文件预加载到页缓存

## ipconfig有什么用？

**主要功能**：
- 查看网络配置：IP地址、子网掩码、网关
- 查看DNS服务器配置
- 显示网络适配器信息
- 刷新DNS缓存（ipconfig /flushdns）
- 释放/重新获取IP地址（ipconfig /release, /renew）

## mysql和redis的数据一致性

**常见方案**：
1. **延迟双删**：删除缓存 → 更新数据库 → 延迟删除缓存
2. **先更新数据库再删除缓存**：降低不一致概率
3. **使用消息队列**：异步同步数据
4. **分布式锁**：保证操作原子性

**问题**：先更新mysql再更新redis存在问题：
- 如果Redis更新失败，会导致数据不一致
- 建议使用"删除缓存"而不是"更新缓存"

## mysql备份

**binlog（二进制日志）**：
- 记录所有修改数据的SQL语句（逻辑备份）
- 用于主从复制和数据恢复
- 属于Server层

**redo log（重做日志）**：
- 记录物理页面的修改（物理备份）
- 用于崩溃恢复，保证事务持久性
- 属于InnoDB存储引擎层

## 详细说说binlog作用的流程？

**binlog写入流程**：
1. 事务执行过程中，修改操作先写入redo log buffer(记录的是物理变更信息，如：页号X，偏移Y，旧值A，新值B)
2. 事务提交时，按照两阶段提交协议：
   - prepare阶段：redo log写入磁盘
   - commit阶段：binlog写入磁盘，然后redo log标记commit
3. binlog记录格式有三种：STATEMENT、ROW、MIXED(ROW+STATEMENT)

### STATEMENT 格式

**定义**：
记录 SQL 语句的文本内容，例如：
```sql
INSERT INTO table VALUES(1, 'data');
```
主库执行 SQL 时，将语句写入 binlog，从库重放相同语句以同步数据。

**核心特点**

- **优点：**
  - 日志体积小：仅记录 SQL 文本，相比 ROW 格式节省大量存储空间，尤其适合批量操作（如 `UPDATE` 表中 10 万行数据，仅记录一条 SQL）。
  - 可读性强：直接查看 binlog 即可理解操作内容，无需额外解析工具。
- **缺点：**
  - 复制一致性风险：
    - 非确定性函数（如 `NOW()`、`RAND()`）在主从库执行结果可能不同，导致数据不一致。
    - 依赖上下文的操作（如 `AUTO_INCREMENT`、触发器、存储过程）可能因环境差异（如表结构、数据量）导致从库执行结果异常。
  - 权限依赖：从库需具备与主库相同的权限才能执行 SQL，否则复制会失败。

---

### ROW 格式

**定义**：
记录数据行的物理变更，即修改前的行（Before Image）和修改后的行（After Image）。例如：
```sql
UPDATE table SET col=2 WHERE id=1
```
binlog 会记录 id=1 的行修改前和修改后的完整数据。

**核心特点**

- **优点：**
  - 复制高度一致：直接记录数据变化，不依赖 SQL 执行逻辑，彻底避免因函数、权限等问题导致的主从不一致（如主库执行 `UPDATE` 时使用 `LIMIT 1` 但未加条件，ROW 会记录具体修改的行）。
  - 安全性高：可精确控制复制范围（如过滤表、列），且 DDL 与 DML 操作均被准确记录。
- **缺点：**
  - 日志体积大：每一行数据变更都需记录前后镜像，尤其在批量操作时（如 `UPDATE` 全表），binlog 可能快速膨胀，占用大量磁盘空间和 IO 资源。
  - 可读性差：需通过 `mysqlbinlog --base64-output=decode-rows -v` 等工具解析，原始日志为二进制格式，难以直接查看。
  - 敏感数据暴露风险：若表中包含密码、身份证等敏感字段，ROW 格式会将数据明文写入 binlog，存在安全隐患。



**作用**：
- 主从复制：从库读取主库binlog进行数据同步
- 数据恢复：结合全量备份和binlog进行增量恢复
- 数据审计：追踪数据变更历史

事务执行过程中发生的事情：
 
        Buffer Pool 是 InnoDB 存储引擎的内存缓存区，用于缓存磁盘中的数据页（Data Page）。当执行数据修改（如 UPDATE、INSERT）时，InnoDB 会先将目标数据页从磁盘加载到 Buffer Pool 中，在内存中直接修改数据页的内容。


1. 事务开始，修改 Buffer Pool 中的数据页，标记为脏页；
2. 同时，物理变更记录写入 redo log buffer；
3. 事务提交时，通过两阶段提交：  
  redo log 先写入磁盘（prepare 阶段）；    
  binlog 写入磁盘后，redo log 标记为 commit（commit 阶段）；  
1. 后续由 InnoDB 后台线程将脏页刷盘，确保数据持久化。