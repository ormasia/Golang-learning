- [腾讯CDG金融科技后台开发一面凉经](#腾讯cdg金融科技后台开发一面凉经)
  - [数组和链表的区别，使用场景](#数组和链表的区别使用场景)
  - [树和图的区别](#树和图的区别)
  - [深度优先和广度优先的区别，为什么要用dfs和bfs？](#深度优先和广度优先的区别为什么要用dfs和bfs)
  - [三次握手，发送的内容都有什么？](#三次握手发送的内容都有什么)
  - [第三次握手丢了，客户端直接发送数据了，服务端会怎样？](#第三次握手丢了客户端直接发送数据了服务端会怎样)
  - [第三次握手的目的是什么？](#第三次握手的目的是什么)
  - [序列号怎么生成的，从0开始吗？](#序列号怎么生成的从0开始吗)
  - [TCP数据包里包含哪些，有ACK字段吗，这个ACK和三次握手的有什么不一样？](#tcp数据包里包含哪些有ack字段吗这个ack和三次握手的有什么不一样)
  - [HTTP和HTTPs的区别](#http和https的区别)
  - [https四次挥手过程，每次挥手发生什么？](#https四次挥手过程每次挥手发生什么)
  - [发送的数字证书为什么可靠？，客户端如何判断？](#发送的数字证书为什么可靠客户端如何判断)
  - [linux常见命令](#linux常见命令)
  - [linux文件系统](#linux文件系统)
  - [vim打开一个文件的原理](#vim打开一个文件的原理)
  - [数据存储引擎有哪些？](#数据存储引擎有哪些)
  - [innodb存储引擎和mysql的区别](#innodb存储引擎和mysql的区别)
  - [索引怎么实现？](#索引怎么实现)
  - [为什么使用b+树？，不是二叉树？](#为什么使用b树不是二叉树)
  - [b+树的时间复杂度为什么是O(logN)？](#b树的时间复杂度为什么是ologn)
  - [联合索引 (a,b,c) (b,a,c) (c,b,a) 有什么区别](#联合索引-abc-bac-cba-有什么区别)
  - [联合索引把什么样的字段放在第一个（用户登录状态和uid哪个放第一个）](#联合索引把什么样的字段放在第一个用户登录状态和uid哪个放第一个)
    - [典型读取路径](#典型读取路径)
      - [结论](#结论)
  - [可重复读有没有幻读现象，什么情况下出现幻读？](#可重复读有没有幻读现象什么情况下出现幻读)
  - [redis持久化方式，快照怎么实现？](#redis持久化方式快照怎么实现)
    - [BGREWRITEAOF](#bgrewriteaof)
  - [快照怎么保证和上一个快照不冲突（提示有个静态变量，？）](#快照怎么保证和上一个快照不冲突提示有个静态变量)

# 腾讯CDG金融科技后台开发一面凉经
按简历上的技术栈一个一个问，不问项目(问项目有没有上线)，没有手撕 

自我介绍

30分钟秒挂
## 数组和链表的区别，使用场景

数组内存空间连续，支持随机查找，插入效率低；
链表不连续，插入效率高，不支持随即查询；
**扩展方面：静态数组不支持扩容，动态数组达到容量后会扩容，链表不受限制，天然无限扩展，但是容易导致内存碎片；**  
**数组符合缓存局部性原理，链表不符合；**

## 树和图的区别
树没有环，结构上有父子节点的概念；
图分为有向图和无向图，可成环，图可以看作是多个子树拼在一起；
树是层次结构，而图存在复杂的拓扑结构
存储方式：树可以使用数组或链表存储，图可以使用邻接矩阵（稠密）或邻接表存储（稀疏）

## 深度优先和广度优先的区别，为什么要用dfs和bfs？
深度优先会立即判断这次循环是否满足条件，用于判断是否可达  
广度优先适合于搜索最短路径，

## 三次握手，发送的内容都有什么？
syn 
ack syn seq ？
ack seq
1. 客户端发送SYN包，包含初始序列号（ISN）和SYN标志位
2. 服务端收到SYN包后，回复一个SYN-ACK包，包含服务端的初始序列号（ISN）和确认号（ACK），同时设置SYN和ACK标志位
3. 客户端收到SYN-ACK包后，发送一个ACK包，确认服务端的SYN包，包含确认号（ACK）和自己的序列号（seq）


## 第三次握手丢了，客户端直接发送数据了，服务端会怎样？
拒绝，因为不是ack请求的数据，*服务端返回RST包，客户端意识到连接建立失败重新三次握手*

## 第三次握手的目的是什么？
证明服务端能向客户端通信

## 序列号怎么生成的，从0开始吗？
随机一个数，防止被模拟tcp请求

## TCP数据包里包含哪些，有ACK字段吗，这个ACK和三次握手的有什么不一样？
握手阶段：ACK 用来“确认 SYN、建立会话”；  
   确认对方 SYN 序列号，同时协商初始序列（ISN），建立连接

数据阶段：ACK 用来“确认数据字节、滑动窗口”。  
   累积确认已收到的用户数据字节，维持可靠传输与流量控制

## HTTP和HTTPs的区别
https在应用层和传输层直接还需要经过tls/ssl证书认证

## https四次挥手过程，每次挥手发生什么？
主动关闭方 fin  
closing  
对方发送完所有数据 发送fin  
进入timewait(2MSL)  

## 发送的数字证书为什么可靠？，客户端如何判断？
数字证书之所以可靠，因为其公钥等主体信息被权威 CA 用私钥 签名；客户端通过 证书链+签名校验+撤销检查 来确认“证书内容未被篡改且发行者受信”。

## linux常见命令

## linux文件系统
权限 rw--
inode

## vim打开一个文件的原理
usr/bin 下的vim命令，  
权限验证，  
系统调用读到内存  
渲染到vim编辑界面  

## 数据存储引擎有哪些？
innoDB myaism？

## innodb存储引擎和mysql的区别
存储引擎是mysql引擎层的一种，MySQL分为server层和引擎层

## 索引怎么实现？
b+树？？

## 为什么使用b+树？，不是二叉树？
b+树多路搜索树？查询次数稳定，树高小，支持范围查询
二叉树不利于插入和规则查询

## b+树的时间复杂度为什么是O(logN)？
他就是多路的二叉搜索树，

##  联合索引 (a,b,c) (b,a,c) (c,b,a) 有什么区别
最左匹配原则

## 联合索引把什么样的字段放在第一个（用户登录状态和uid哪个放第一个）
### 典型读取路径

场景 A：SELECT … WHERE uid=? AND login_status=1 ➜ (uid, login_status) 可一次命中；若顺序反了，会先扫 50 % 在线/离线，再回表过滤 uid。

场景 B：SELECT … WHERE login_status=1 ORDER BY uid LIMIT 20 ➜ (login_status, uid) 更好，因为要批量按状态分页。

- 覆盖索引考虑

若查询只返回 uid 与 login_status，无论谁在前，都可用“覆盖”避免回表；但过滤行数仍取决于首列选择性。

- 维护 & 写放大

多列索引写入成本 ≈ 单列之和；因此不要为所有列组合都建索引，按 90 % 主流查询做一条即可，其余靠二级索引或全表扫。

#### 结论

         先放高选择性、等值过滤列（如 uid）是通用优化；

         若业务主要按状态批量筛选，再把 login_status 放首位；

         “谁常被 =、谁能最大限度减行数” 就让谁当联合索引第一列。

## 可重复读有没有幻读现象，什么情况下出现幻读？
有就是更新了一个没有select到的数据，导致后面都可以看到这个数据

## redis持久化方式，快照怎么实现？
RDB，数据以二进制方式存储；
COW写时复制，子进程触发

### BGREWRITEAOF

| 阶段                 | 文件/缓冲区                                                                     | 作用                                                                    |
| ------------------ | -------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| **① fork 子进程**     | `temp-rewriteaof.aof`（临时文件，名字形如 *temp-XXXX.aof*）                           | 子进程专用，只在磁盘上可见；位于与现有 `appendonly.aof` **同一目录**，保证后续 `rename` 是同分区原子操作。 |
| **② 父进程持续写**       | - **原有 `appendonly.aof`**：继续追加<br>- **AOF diff 缓冲区**：同时把新写命令缓存到内存中的“差异缓冲区” | 旧文件保持可用；差异缓冲区记录“子进程开始-结束”这段期间产生的增量。                                   |
| **③ 子进程写完临时文件**    | `temp-rewriteaof.aof` 头部 = **RDB 快照**<br>尾部 = 把快照中的键值对转成最精简写命令             | 生成完毕后，向父进程发送 `AOF rewrite finished` 信号。                               |
| **④ 父进程 flush 差异** | 先把 diff 缓冲区里的命令一次性 **追加到临时文件尾部**                                           | 这样临时文件就包含了“快照 + 重写期间全部增量”。                                            |
| **⑤ 原子替换**         | `rename(temp-rewriteaof.aof, appendonly.aof)`                              | 同目录 `rename` 在 ext4/XFS 等本地文件系统中是 **原子** 的：任何时刻磁盘上只有一份正式 AOF。         |
| **⑥ 备份（可选）**       | 旧 `appendonly.aof` 根据需要手动或脚本移走，如 `appendonly.aof.20250708.bak`             | Redis 不自动保留旧文件；若要留历史，可在 `rename` 成功后异步复制或移动备份。                        |


- 重写时的内存放大小贴士

      每条写命令会被同时写到 旧 AOF 文件 和 diff 缓冲区，两处都可能触发 COW；

      高写 QPS + 大 appendonly.aof 时，BGREWRITEAOF 比 BGSAVE 更吃内存；

      可在低峰时段手动 BGREWRITEAOF，或提高重写阈值 auto-aof-rewrite-percentage 来降低频率

> hybrid aof 是 Redis 改进版 AOF 重写方式，结合了 RDB 快照和增量写命令，性能更优。

## 快照怎么保证和上一个快照不冲突（提示有个静态变量，？）
要保证 Redis RDB 快照不与上一个快照冲突，Redis 采用了以下机制：

1. **使用临时文件 + 原子重命名**：
   - Redis 子进程不会直接写入到最终的 RDB 文件（如 `dump.rdb`），而是先写入到一个临时文件（如 `temp-<pid>.rdb`）
   - 只有当新的临时文件完全写入成功后，才会通过原子的 `rename()` 系统调用替换旧的 RDB 文件
   - 这确保了在任何时刻，系统中都有一个完整可用的 RDB 文件

2. **内部状态标志（静态变量）**：
   - Redis 维护一个内部状态变量（类似于 `rdb_save_in_progress` 标志）
   - 当执行 BGSAVE 时，这个状态变量会被设置为 1，表明有 RDB 保存操作正在进行
   - 这个标志防止同时启动多个 BGSAVE 操作，避免资源竞争和文件冲突
   - 只有当一个 BGSAVE 完全结束后，这个标志才会被重置，允许新的 BGSAVE 开始

3. **COW 机制保证数据一致性**：
   - 使用写时复制（COW）技术，子进程看到的是 fork 时刻的内存快照
   - 主进程继续处理新的请求，修改的内存页会被复制，不影响子进程的数据视图
   - 这确保了生成的快照数据是一个时间点上的一致视图

4. **文件描述符和路径处理**：
   - Redis 会小心管理文件描述符，确保在 RDB 保存过程中不会出现资源泄露
   - 临时文件的命名策略确保即使系统崩溃，也不会与正常的 RDB 文件混淆

当提到"静态变量"时，主要是指这种内部状态管理机制，它防止了并发快照操作可能导致的文件冲突和资源竞争问题。