- [百度文心一言后端开发实习一面5.26](#百度文心一言后端开发实习一面526)
  - [golang基础](#golang基础)
    - [接口类型强制转换为int，有什么隐患？](#接口类型强制转换为int有什么隐患)
    - [数组中add和set方法](#数组中add和set方法)
    - [channel通道关闭读写会发生什么？](#channel通道关闭读写会发生什么)
    - [panic](#panic)
    - [子goroutine发生panic，父goroutine会发生什么？](#子goroutine发生panic父goroutine会发生什么)
    - [goroutine中defer一般在哪里调用？](#goroutine中defer一般在哪里调用)
  - [项目中做的服务调用其他服务出现超时该怎么办？](#项目中做的服务调用其他服务出现超时该怎么办)
    - [context有什么api，怎么知道处理过期了？](#context有什么api怎么知道处理过期了)
    - [服务有没有负载过重的情况(具体排查服务占用资源，比如CPU、内存、IO等)？](#服务有没有负载过重的情况具体排查服务占用资源比如cpu内存io等)
    - [出现这些情况该怎么解决？](#出现这些情况该怎么解决)
  - [怎么向项目的日志输入记录，可以用Linux的什么命令？](#怎么向项目的日志输入记录可以用linux的什么命令)
    - [对Linux文件怎么读写？比如我要具体到输入哪个文件什么数据？](#对linux文件怎么读写比如我要具体到输入哪个文件什么数据)
  - [项目中MySQL怎么监控占用内存，磁盘资源？](#项目中mysql怎么监控占用内存磁盘资源)
  - [在Linux打开一个很大的文件会发生什么？比如2G会发生什么？](#在linux打开一个很大的文件会发生什么比如2g会发生什么)
  - [怎么知道项目中出现了慢查询？怎么排查？具体讲讲流程？](#怎么知道项目中出现了慢查询怎么排查具体讲讲流程)
  - [服务健康检查怎么做？](#服务健康检查怎么做)
  - [某个服务显示内存资源一直占用很高，且还在不断上升，详细讲怎么排查解决？](#某个服务显示内存资源一直占用很高且还在不断上升详细讲怎么排查解决)
  - [知道覆盖索引吗？](#知道覆盖索引吗)
  - [binlog用来做什么？项目中有没有用到？](#binlog用来做什么项目中有没有用到)
  - [MySQL出现主从延迟的原因？](#mysql出现主从延迟的原因)
  - [raft分布式数据库相比redis有什么优势吗？](#raft分布式数据库相比redis有什么优势吗)
  - [redis用来做什么？](#redis用来做什么)
  - [如果lua脚本处理多个切片会出现什么？](#如果lua脚本处理多个切片会出现什么)
  - [Redis集群的基本架构](#redis集群的基本架构)
    - [1. **Slot分片机制**](#1-slot分片机制)
    - [2. **数据分布**](#2-数据分布)
  - [为什么不能跨slot执行？](#为什么不能跨slot执行)
    - [1. **原子性保障**](#1-原子性保障)
    - [2. **分布式一致性问题**](#2-分布式一致性问题)
    - [3. **性能和复杂性**](#3-性能和复杂性)
  - [实际的设计权衡](#实际的设计权衡)
    - [1. **Redis选择的策略**](#1-redis选择的策略)
    - [2. **对比其他系统**](#2-对比其他系统)
  - [解决方案](#解决方案)
    - [1. **Hash Tag技术**](#1-hash-tag技术)
    - [2. **重新设计数据模型**](#2-重新设计数据模型)
    - [3. **应用层协调**](#3-应用层协调)
  - [总结](#总结)
  - [redis的get命令处理多个切片会出现什么？](#redis的get命令处理多个切片会出现什么)
  - [总结：Redis集群中跨slot操作的两个要点](#总结redis集群中跨slot操作的两个要点)
    - [1. **Lua脚本不能跨slot执行的原因**](#1-lua脚本不能跨slot执行的原因)
    - [2. **MGET跨slot的真实情况**](#2-mget跨slot的真实情况)
    - [核心洞察](#核心洞察)
  - [算法：golang实现lru](#算法golang实现lru)

# 百度文心一言后端开发实习一面5.26

## golang基础

### 接口类型强制转换为int，有什么隐患？
精度丢失，可能导致数据错误。
1. **类型断言失败导致panic** - 如果接口实际类型不是int
2. **精度丢失** - float转int时丢失小数部分
3. **数值溢出** - 大范围类型转小范围类型时可能溢出
4. **nil接口panic** - 空接口无法转换
5. **类型不匹配** - 不同数值类型需要分别处理
### 数组中add和set方法
add方法用于向数组中添加元素，set方法用于修改数组中指定位置的元素。
### channel通道关闭读写会发生什么？
关闭通道后，向通道中写入数据会导致panic，
而从通道中读取数据会返回零值且不会阻塞。如果通道已经关闭且没有数据可读，读取操作会立即返回零值。
使用for range遍历已关闭的通道时，会继续读取直到通道为空，但不会阻塞。
返回ok值为false，表示通道已关闭且没有更多数据可读。
通过`len(channel)`检查通道是否关闭是不可靠的，因为它只会返回通道中当前的元素数量，而不会指示通道是否已关闭。
### panic
在Go中，panic是一种运行时错误，通常用于表示程序中的严重问题。当程序发生panic时，它会停止当前的执行，并开始逐层向上返回，直到找到一个defer语句来处理这个panic。如果没有找到相应的defer语句，程序将会崩溃并输出错误信息。
### 子goroutine发生panic，父goroutine会发生什么？

**情况1：子goroutine的panic没有被处理**
- 整个程序会崩溃并退出
- 主goroutine也会被终止
- 程序输出panic信息和堆栈跟踪

**情况2：子goroutine使用defer+recover()处理panic**
- 只有发生panic的子goroutine会终止
- 主goroutine继续正常执行
- 程序不会崩溃

**关键点**：Go中的goroutine之间是平等的，任何一个goroutine发生未处理的panic都会导致整个程序崩溃，而不仅仅是"输出错误信息"。

### goroutine中defer一般在哪里调用？
通常在需要在函数结束时进行对应的操作的地方使用defer，例如释放资源、解锁互斥锁、关闭文件等。不必须写在函数末尾，但通常在goroutine的开始部分调用defer，以确保在goroutine结束时执行清理操作。这样可以确保即使goroutine中发生panic或提前返回，defer中的代码仍然会被执行。

## 项目中做的服务调用其他服务出现超时该怎么办？
通过context包的WithTimeout或WithDeadline来设置超时时间，超时后会返回错误。

### context有什么api，怎么知道处理过期了？
context包提供了以下主要API来处理超时和取消：
- `context.Background()`：返回一个空的上下文，通常用于根上下文。    
- `context.TODO()`：返回一个空的上下文，表示尚未确定的上下文。
- `context.WithCancel(parent)`：返回一个可取消的上下文和取消函数。
- `context.WithTimeout(parent, timeout)`：返回一个带有超时的上下文和取消函数。
- `context.WithDeadline(parent, deadline)`：返回一个带有截止时间的上下文和取消函数。
- `context.WithValue(parent, key, value)`：返回一个携带值的上下文。
- `context.Done()`：返回一个通道，当上下文被取消或超时时，该通道会被关闭。
``` go
func example(ctx context.Context) {
    // 设置超时
    ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel() // 确保取消函数被调用

    select {
    case <-ctx.Done():
        // 处理超时或取消
        fmt.Println("Context done:", ctx.Err())
    case result := <-someOperation(ctx):
        // 正常处理结果
        fmt.Println("Result:", result)
    }
}
```
### 服务有没有负载过重的情况(具体排查服务占用资源，比如CPU、内存、IO等)？
可以通过以下方式排查服务负载过重的情况：
- 使用`top`或`htop`命令查看CPU和内存使用情况。
- 使用`iostat`命令查看磁盘IO情况。
- 使用`netstat`命令查看网络连接情况。
- 使用`go tool pprof`分析Go应用的性能瓶颈。

### 出现这些情况该怎么解决？
cpu过高可以通过优化代码逻辑、减少不必要的计算、使用缓存等方式来解决；
    具体来说：
内存过高可以通过优化数据结构、减少内存泄漏等方式来解决；
IO过高可以通过优化数据库查询、使用连接池等方式来解决。

## 怎么向项目的日志输入记录，可以用Linux的什么命令？
可以使用`logger`命令向**系统日志**中写入日志信息，例如：
```bash
logger "This is a log message"
```
也可以使用`echo`命令将日志信息输出到标准输出，然后通过管道将其传递给`logger`：
```bash
echo "This is a log message" | logger
```
### 对Linux文件怎么读写？比如我要具体到输入哪个文件什么数据？
echo 命令可以向文件写入数据，例如：
```bash
echo "Hello, World!" > /path/to/file.txt
```
要读取文件内容，可以使用`cat`命令：
```bash
cat /path/to/file.txt
```
tail命令可以实时查看文件的新增内容，例如：
```bash
tail -f /path/to/file.txt
```
## 项目中MySQL怎么监控占用内存，磁盘资源？
可以使用以下方法监控MySQL的资源占用情况：
- 使用`SHOW STATUS`命令查看MySQL的状态信息，包括内存使用情况、磁盘IO等。
- 使用`SHOW PROCESSLIST`命令查看当前正在执行的查询和连接。
- 使用`EXPLAIN`命令分析查询的执行计划，优化查询性能。

## 在Linux打开一个很大的文件会发生什么？比如2G会发生什么？
首先是生成一个文件描述符，操作系统会为该文件分配一个文件描述符。然后，操作系统会尝试将文件的内容加载到内存中。如果文件过大，可能会导致以下情况：
- **内存不足**：如果系统内存不足以加载整个文件，操作系统会将文件分成多个页面（通常是4KB或8KB），并按需加载到内存中。
- **页面交换**：如果内存不足以容纳所有页面，操作系统会使用页面置换算法，将一些不常用的页面从内存中交换到磁盘上，以腾出空间加载新的页面。
- **延迟加载**：操作系统可能不会一次性加载整个文件，而是按需加载，即在访问文件的特定部分时才将其加载到内存中。
- **文件映射**：操作系统可能会使用文件映射技术，将文件的部分内容映射到进程的地址空间中，以便在访问时自动加载。

## 怎么知道项目中出现了慢查询？怎么排查？具体讲讲流程？
- 直观感受，程序响应变慢，用户反馈操作卡顿。
- gorm会自动输出超过200ms的查询日志。(实习过程中遇到过)
- 打印日志，执行sql时会输出sql执行时间，作为第一个排查依据。
- 开启慢查询日志，MySQL可以配置慢查询日志，记录执行时间超过一定阈值的查询。
具体的操作是：
```sql
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1; -- 设置慢查询时间阈值为1秒
```
- 使用`EXPLAIN`命令分析慢查询的执行计划，查看是否有索引未使用、全表扫描等问题。

## 服务健康检查怎么做？

## 某个服务显示内存资源一直占用很高，且还在不断上升，详细讲怎么排查解决？


## 知道覆盖索引吗？
指的是查询的所有字段都在索引中，不需要回表查询数据行。这样可以提高查询效率，减少磁盘I/O操作。

## binlog用来做什么？项目中有没有用到？
**binlog用于记录MySQL的所有数据修改操作**一般会使用binlog来实现数据的备份和恢复，以及在主从架构中进行数据同步。
项目中数据做了主从配置，binlog用于主从同步。

## MySQL出现主从延迟的原因？
网络波动
从库的硬件性能不足
binlog积压：
    主库写入速度快于从库读取速度，导致binlog积压。
    大事务导致的日志积压

**补充完善：**
- 设计限制：单线程回放、串行化约束
- 资源瓶颈：CPU、内存、磁盘I/O、网络
- 负载不均：主从库负载分配不合理
- 事务特征：大事务、复杂事务、热点数据竞争
- 配置不当：安全性配置过于保守、并行度不足

## raft分布式数据库相比redis有什么优势吗？
etcd 避免脑裂问题，提供强一致性保证。
天然分布式场景，提供备份保证，高可用性。

## redis用来做什么？
缓存
消息队列
分布式锁

## 如果lua脚本处理多个切片会出现什么？
Lua脚本不能跨slot执行的原因涉及到Redis集群的设计原理和一致性保障。让我详细解释：

## Redis集群的基本架构

### 1. **Slot分片机制**
```
Redis集群将16384个slot分布在不同节点上：
Node A: slots 0-5460
Node B: slots 5461-10922  
Node C: slots 10923-16383

每个key通过CRC16算法计算后模16384得到slot号
```

### 2. **数据分布**
```bash
# 示例：key的slot计算
user:1001 -> CRC16("user:1001") % 16384 = 8934 -> Node B
user:1002 -> CRC16("user:1002") % 16384 = 3421 -> Node A
product:500 -> CRC16("product:500") % 16384 = 12450 -> Node C
```

## 为什么不能跨slot执行？

### 1. **原子性保障**
```lua
-- 假设这个脚本涉及多个slot
local val1 = redis.call('GET', 'user:1001')  -- Node B
local val2 = redis.call('GET', 'user:1002')  -- Node A
redis.call('SET', 'result:123', val1 + val2) -- Node C
```

**问题**：如果允许跨slot执行，Redis无法保证整个脚本的原子性，因为：
- 不同节点可能在不同时间点执行
- 网络分区可能导致部分操作失败
- 无法实现分布式事务的ACID特性

### 2. **分布式一致性问题**
```
时间线问题：
T1: Node A执行GET user:1002
T2: 其他客户端修改Node A上的user:1002  
T3: Node B执行GET user:1001
T4: Node C执行SET result:123

结果：脚本看到的数据可能不是一致的快照
```

### 3. **性能和复杂性**
如果支持跨slot执行，Redis需要：
- **分布式锁机制**：确保跨节点原子性
- **两阶段提交**：协调多节点操作
- **死锁检测**：处理跨节点死锁
- **网络异常处理**：处理节点间通信失败

这会显著增加系统复杂性和性能开销。

## 实际的设计权衡

### 1. **Redis选择的策略**
```
简单 > 复杂
高性能 > 分布式事务
明确的约束 > 隐性的复杂性
```

Redis选择**拒绝跨slot操作**，强制用户重新设计数据模型，而不是实现复杂的分布式事务机制。

### 2. **对比其他系统**
```
MongoDB: 支持跨分片事务，但性能开销大
Cassandra: 不支持跨分区事务
TiDB: 支持分布式事务，但架构复杂
Redis: 拒绝跨slot，保持简单高效
```

## 解决方案

### 1. **Hash Tag技术**
```bash
# 使用{}确保相关key在同一slot
user:{1001}:profile
user:{1001}:orders  
user:{1001}:balance

# 这些key都会根据"1001"计算slot，保证在同一节点
```

### 2. **重新设计数据模型**
```lua
-- 将相关数据聚合在一个key中
local user_data = redis.call('HMGET', 'user:1001', 'profile', 'balance', 'orders')
-- 而不是分散在多个key中
```

### 3. **应用层协调**
```go
// 在应用层分别调用不同节点
val1 := redisNodeA.Get("user:1002")
val2 := redisNodeB.Get("user:1001") 
result := val1 + val2
redisNodeC.Set("result:123", result)
```

## 总结

Lua脚本不能跨slot执行是Redis集群**有意的设计选择**：

1. **保证原子性**：单节点内的操作天然原子
2. **避免分布式复杂性**：不需要实现分布式事务
3. **保持高性能**：避免跨节点协调开销
4. **明确的约束**：强制用户考虑数据局部性

这种设计虽然限制了灵活性，但换来了：
- **极高的性能**
- **简单的架构** 
- **明确的行为**
- **高可用性**

这正是Redis"简单就是美"设计哲学的体现。
## redis的get命令处理多个切片会出现什么？
## 总结：Redis集群中跨slot操作的两个要点

### 1. **Lua脚本不能跨slot执行的原因**

**根本原因：设计哲学的选择**
- Redis选择了"简单胜过复杂"的设计理念
- 避免实现复杂的分布式事务机制
- 将复杂性转移给应用层处理

**技术层面的考量：**
- **原子性保障**：单节点内操作天然原子，跨节点需要分布式协调
- **性能优先**：避免跨节点通信的开销和延迟
- **架构简化**：不需要实现两阶段提交、分布式锁等复杂机制

**解决方案：**
- 使用Hash Tag: `{user}:1001`, `{user}:1002`
- 重新设计数据模型，保证相关数据的局部性
- 在应用层进行多次调用和结果合并

### 2. **MGET跨slot的真实情况**

**我的认识纠正过程：**

**❌ 错误理解：** 
- 以为是"一致性"问题
- 以为需要自己实现复杂的客户端逻辑

**✅ 正确理解：**
- **服务器层面**：Redis节点确实不支持跨slot的MGET，会返回CROSSSLOT错误
- **客户端层面**：主流客户端库（go-redis、redis-py-cluster、Jedis等）都已经透明地解决了这个问题

**实际情况：**
```go
// 用户代码 - 看起来像普通的MGET
results := redisClusterClient.MGet("user:1001", "user:1002", "product:500")

// 客户端内部自动处理：
// 1. 计算每个key的slot
// 2. 按节点分组  
// 3. 并发请求不同节点
// 4. 合并结果返回
```

### 核心洞察

1. **分层处理**：Redis在不同层面有不同的限制和解决方案
   - 服务器层：严格限制，保持简单
   - 客户端层：智能封装，用户友好

2. **设计权衡**：Redis选择将复杂性推给客户端，而不是在服务器端实现分布式协调

3. **实用性**：对于普通开发者来说，现代客户端库已经很好地解决了跨slot访问问题，使用起来几乎无感知

**关键区别：Lua脚本的跨slot限制无法被客户端"绕过"（因为脚本必须在单个节点执行），而MGET的限制可以被客户端透明地解决。**
## 算法：golang实现lru
