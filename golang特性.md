- [golang语言上的特性](#golang语言上的特性)
  - [GC](#gc)
    - [① **第一次“短暂停” (STW #1)——抓根并放进灰队列**](#-第一次短暂停-stw-1抓根并放进灰队列)
    - [② **开启“混合写屏障”——边运行边保护**](#-开启混合写屏障边运行边保护)
    - [③ **并发做两件事**](#-并发做两件事)
    - [④ **第二次“短暂停” (STW #2)——收尾**](#-第二次短暂停-stw-2收尾)
    - [⑤ **后台 Scavenger \& 等待下一轮**](#-后台-scavenger--等待下一轮)
    - [总结](#总结)
  - [GMP](#gmp)
    - [关键点](#关键点)
    - [阻塞类型](#阻塞类型)
      - [阻塞补充](#阻塞补充)
      - [常见问题](#常见问题)
      - [一些系统调用](#一些系统调用)
  - [内存分配策略(内存逃逸)](#内存分配策略内存逃逸)
    - [Go 内存分配全景图（含虚拟内存视角）](#go-内存分配全景图含虚拟内存视角)
      - [目录](#目录)
      - [1. 进程虚拟地址空间分区](#1-进程虚拟地址空间分区)
        - [指针槽（Pointer Slot）](#指针槽pointerslot)
          - [GC 扫描根：哪些地方的指针槽会被检查？](#gc-扫描根哪些地方的指针槽会被检查)
      - [2. 编译期逃逸分析](#2-编译期逃逸分析)
      - [3. 堆内分配层级](#3-堆内分配层级)
      - [4. 可增长栈](#4-可增长栈)
      - [5. 调优速查表](#5-调优速查表)
      - [6. 总结](#6-总结)
  - [同步原语](#同步原语)
  - [channel(CSP)](#channelcsp)
    - [为什么使用CSP](#为什么使用csp)
    - [抽象是什么？——“信箱＋门铃”](#抽象是什么信箱门铃)
    - [一条 send/recv 的完整路径](#一条-sendrecv-的完整路径)
    - [select 如何做到“任意一个就绪”](#select-如何做到任意一个就绪)
    - [数据拷贝情况](#数据拷贝情况)
      - [配对直传的特殊情况](#配对直传的特殊情况)
      - [性能提示](#性能提示)


# golang语言上的特性

## GC

---

### ① **第一次“短暂停” (STW #1)——抓根并放进灰队列**

1. 让全部 goroutine 暂停约 100 微秒。
2. **根指针**（静态区、各栈帧、寄存器影子、finalizer 队列、cgo 句柄）全部“刷成灰色”；
3. 把这些灰节点丢进一个**灰队列**，等着后面的标记线程去处理。
4. 立即恢复业务代码（Mutator）继续运行。

---

### ② **开启“混合写屏障”——边运行边保护**

* 业务代码写指针时，编译器插入屏障：

  1. 先把 **旧指针** 再次染灰（保证它不会被丢失）；
  2. 再写入 **新指针**。
* 这样可确保“不出现黑节点直接指向白节点”的违规情况。

---

### ③ **并发做两件事**

| 并发角色            | 工作内容                                 | 结果             |
| --------------- | ------------------------------------ | -------------- |
| **Sweeper**     | 清理上一次 GC 留下来的“白色 Span”               | 让分配器立刻可以复用空闲内存 |
| **Mark Worker** | 循环处理灰队列：<br>取灰 → 扫指针槽 → 子对象染灰 → 自身染黑 | 灰队列里的对象越来越少    |

> 标记期间，**分配线程如果分配太多**，会被动承担一点标记工作（称为 *GC Assist*），防止堆失控上涨。

---

### ④ **第二次“短暂停” (STW #2)——收尾**

* 当灰队列快清空时，再停一次（通常 < 1 ms）：

  1. 处理最后一撮残灰；
  2. 翻转全局位图——白⇄黑；
  3. 计算新的 `heap_goal`（决定下一轮 GC 何时触发）。

---

### ⑤ **后台 Scavenger & 等待下一轮**

1. **Scavenger** 在后台把完全空闲的页用 `madvise` 还给操作系统，降低 RSS。
2. 运行时的 **Pacer** 监控堆大小：

   * 当 `heap_live` ≥ `heap_goal`（由 `GOGC` 或 `GOMEMLIMIT` 推算）时，启动下一轮 GC。
3. 如果 CPU 空闲，Scavenger 会更积极地回收（Go 1.22 Idle Scavenge）。

---

### 总结

> 抓根→灰队列→并发清扫+标记→灰清空再停一次→翻位图→后台还页，循环往复。

| 术语                          | 一句话解释                                                                                       | 在 Go GC/运行时中的角色                                                                                          |
| --------------------------- | ------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| **Scavenger**               | “清道夫”线程。Go runtime 里专门负责把完全空闲的 **Span** 或者闲置大页归还给操作系统。                                      | 当某段 Span 中的对象都被 GC 回收、且整块页无人再用时，Scavenger 会调用 **`madvise`**（Linux）或对应系统调用，把这部分物理内存标记为可回收，从而降低进程 **RSS**。 |
| **`madvise`**               | Linux/Unix 系统调用：*memory advise*。可告诉内核“这段虚拟地址以后不再用、可回收”（`MADV_DONTNEED`）。                    | Scavenger 调用 `madvise` 让内核把对应物理页移出工作集。虚拟地址仍保留，只是再次访问会触发缺页重新映射。                                           |
| **RSS** (Resident Set Size) | “常驻集大小”：进程当前真正占用的物理内存页总量。`top`/`htop` 里的 **RES** 列。                                         | 把空闲页 `madvise` 出去后，RSS 会下降；而 `heap_inuse`（虚拟堆占用）大小并不一定同步下降。                                              |
| **Pacer**                   | Go 运行时里的 **自适应节奏控制器**。实时计算“应该何时启动下一轮 GC、应该多快标记”以保证 **heap\_live ≤ heap\_goal**。             | 根据当前分配速率、`GOGC` 或 `GOMEMLIMIT` 动态调整：<br>• 标记 worker 数量<br>• 写屏障触发强度<br>• GC 触发时机                         |
| **heap\_live / heap\_goal** | `heap_live`：当前存活堆字节数<br>`heap_goal`：允许堆长到的上限，`heap_live * (1+GOGC/100)`；或由 `GOMEMLIMIT` 控制。 | 只要 `heap_live` ≥ `heap_goal`，Pacer 就触发新一轮 GC。GC 结束时会重新计算下一轮 `heap_goal`。                                 |



## GMP

### 关键点
| 关键词                     | 面试与实战要点                                                                    |
| ----------------------- | -------------------------------------------------------------------------- |
| **G (Goroutine)**       | 逻辑协程。结构体里保存 PC、SP、栈指针、状态。创建时栈仅 2 KB，可按需增长。                                 |
| **M (Machine)**         | 绑定到 **1 个内核线程**（`pthread`/`LWP`）。真正执行指令。                                   |
| **P (Processor)**       | 调度器的 **本地队列 + 运行时资源包**。拥有可执行 G 队列、对象分配缓存、timer 列表等。`GOMAXPROCS=N` 即 N 个 P。 |
| **调度循环**                | `M` 取到 `P` → 从 `P` 的 G 队列弹出 G → 运行；G 结束或阻塞后重新入队 (`park`)。                  |
| **全局运行队列 & work-steal** | 队列失衡时，M 会从全局或其他 P 偷一半 G，保证负载均衡。                                            |
| **系统调用阻塞**              | G 触发阻塞系统调用 → M 进入 **syscall 状态** 并暂时占用 P；一旦阻塞，调度器会摘掉 P 让另一条 M 继续跑。         |
| **抢占 & STW**            | Go 1.14 起支持异步抢占：编译器在函数栈检查点插 “抢占标志”；sysmon 线程定期向抢占点注入中断，避免长时间不让出 P。         |


### 阻塞类型

| 阻塞类别          | 典型场景 / 系统调用                                         | 运行时策略                                                                                | 对调度的影响                                                        |
| ------------- | --------------------------------------------------- | ------------------------------------------------------------------------------------ | ------------------------------------------------------------- |
| **网络 I/O 阻塞** | `recv`, `accept`, `send` 等 Socket 调用                | **统一走 netpoll**：将 fd 设为 non-blocking → `epoll_wait`/`kqueue`/IOCP 由专门的网络轮询线程（不占 P）托管 | G 会被挂到 *等待队列*；就绪后由 netpoll 线程把 G 注入某个 P 的本地队列，**几乎无停顿**       |
| **文件 I/O 阻塞** | `read`, `write`, `open` 等普通文件、管道、TTY                | 在多数系统（Linux、BSD、macOS）**无法 epoll**；Go 直接调用阻塞系统调用                                     | 调用线程 M 进入 **syscall 状态**，P 被摘走让给别的 M；调用完成后 M 再抢 P，**线程数可能膨胀** |
| **通用系统调用阻塞**  | `sleep`, `select`, `syscall.Syscall*` (C 挂起)、CGO 回调 | 路径与文件 I/O 相同：进入 `M.syscall`，P 被摘走                                                    | 只要调用时间可控（<10 µs）影响轻；否则容易产生大量内核线程                              |
#### 阻塞补充
为什么网络 I/O 可以“看上去不阻塞”？

Go 在 net 包内部把 fd 设为非阻塞；真正阻塞的 epoll_wait/kqueue 在一个不占 P 的后台线程。

轮询线程拿到就绪事件后调用 injectglist() 把对应 G 加到 P 的 runq。业务 Goroutine 几乎无感。

文件 I/O 为何难非阻塞？

Linux 的 epoll 仅对 socket / pipe / eventfd 等“可轮询 fd”友好；常规文件始终 ready，无法用 epoll 判定“何时可读写”。

Go 因此只能用阻塞 read/write；为不堵 P，只能让调用线程 M 独占一次 syscall。

syscall 阻塞流程小结

G 调 syscall ─► G.state = Gsyscall
                M.state = Msyscall (持有 P)
                runtime  → 抢下 P 给新 M
                … 业务继续 …
syscall 返回 ─► M 尝试重新获取空闲 P
I/O_uring 与 AIO 的现状

Go 1.22 已引入实验性的 I/O_uring 文件 I/O 支持（GOEXPERIMENT=iosharedlocks），未来有望让文件 I/O 也进入非阻塞路径。

在此之前，大文件并行读写建议用 bufio, sync.Pool 或拆分 goroutine 限流。

#### 常见问题
| 症状             | 排查思路                                                                 |
| -------------- | -------------------------------------------------------------------- |
| **线程数暴涨**      | `pprof goroutine` + `runtime.NumCgoCall()` —— 多半卡在文件或 CGO syscall 阻塞 |
| **netpoll 延迟** | `GODEBUG=netdns=2,gctrace=1` 观察 epoll wait & latency，检查是否 FD 饱和      |
| **I/O 抖动**     | Deploy 时调高 `ulimit -n`，限制并发文件读写 goroutine 数量                         |


#### 一些系统调用
| 场景                     | 调用                            | 作用                                 |
| ---------------------- | ----------------------------- | ---------------------------------- |
| **Mutex / chan 等同步阻塞** | `futex(FUTEX_WAIT)`           | `gopark` 把 G 挂入 sema 队列，调用 futex 睡 |
| **唤醒同步阻塞**             | `futex(FUTEX_WAKE, n)`        | `semawakeup` 唤醒 n 个睡眠 G            |
| **网络 poll**            | `epoll_wait`                  | poller 线程阻塞在这里，不占 P                |
| **线程创建 / Park P**      | `clone` / `pthread_create`    | 新建 M；`futex` 也可用作 handoff          |
| **定时器**                | `clock_gettime` + `nanosleep` | timer 线程做 back-off 等待最近到期          |

所以：“睡” 大多是 futex WAIT；“醒” 大多是 futex WAKE；网络事件靠 epoll_wait；要新线程就 clone。记住这三个名字，日志里一看就懂。  

runq 空 → 随机偷邻居一半 G
I/O / chan / mutex / syscall / Gosched / GC 抢占  → 触发 gopark 切换
阻塞睡 FutexWait  ←→  唤醒 FutexWake
网络全靠 epoll_wait，线程靠 clone


## 内存分配策略(内存逃逸)
### Go 内存分配全景图（含虚拟内存视角）

> **记忆口诀**
> **「静态常驻区、局部先上栈、跨域才上堆；  
> Tiny 装小块，MCache 切 Size；   
> GC 三色漂，Scavenger 还 OS；  
> Pool 把短命复用，Cap 把扩容堵死。」**

---

#### 目录

1. [进程虚拟地址空间分区](#1-进程虚拟地址空间分区)
2. [编译期逃逸分析](#2-编译期逃逸分析)
3. [堆内分配层级](#3-堆内分配层级)
4. [可增长栈](#4-可增长栈)
5. [调优速查表](#5-调优速查表)
6. [总结](#6-总结)

---

#### 1. 进程虚拟地址空间分区

| 虚拟区块                         | 典型对象 / 管理者                       | 物理页何时真正占用                             | GC 是否扫描      |
| ---------------------------- | -------------------------------- | ------------------------------------- | ------------ |
| **静态数据段**（`.data / .bss`）    | 包级变量、常量、VTable                   | 进程启动时按页加载（常驻或按需换页）                    | 仅扫描内部指针      |
| **栈**（每个 goroutine 独享，可伸缩）   | *不逃逸* 的局部变量、返回值、寄存器快照            | 首次访问触发缺页；收缩时可能被内核回收                   | 否            |
| **堆**（Arena / Span / Object） | 逃逸对象、`new`/`make`、跨 goroutine 数据 | 写时分配；空闲 Span 由 Scavenger `madvise` 返还 | 是            |
| **映射 / C 内存**（mmap、CGO）      | `syscall.Mmap`、C `malloc`        | 懒加载或显式分配                              | 视内部是否含 Go 指针 |

> **虚拟内存提醒**：上述区块全部位于 **用户态虚拟地址空间**。只有当页面被写入或保留时才真正占用物理 RAM；空闲页可被操作系统换出或释放。

##### 指针槽（Pointer Slot）

在 GC 位图中，以 **machine‑word**（64 位机为 8 B）为粒度划分内存格：

| 位图位 | 槽类型     | 含义                       |
| --- | ------- | ------------------------ |
| `1` | **指针槽** | 该 8 B 存放有效指针，GC 需要沿此继续标记 |
| `0` | **值槽**  | 普通数值或浮点，GC 无需理会          |

* 编译器为**静态区、堆对象、栈帧**都生成精确位图，GC 只扫描指针槽，避免误标／漏标。
* 指针槽理念让 Go 实现了 **完全精确 GC**，同时保持遍历成本最小。

###### GC 扫描根：哪些地方的指针槽会被检查？

| 根区域                        | 说明                | 扫描方式                                  |
| -------------------------- | ----------------- | ------------------------------------- |
| **静态区 (`.data` / `.bss`)** | 包级变量、常量中的指针字段     | 按对象位图——只读标记为 1 的指针槽                   |
| **所有活跃栈帧**                 | 每个 goroutine 的调用栈 | 编译器为栈帧生成位图，GC 逐帧扫描指针槽                 |
| **寄存器 & runtime root**     | 暂存于寄存器的指针、调度器内部表  | 由写屏障和 runtime 保证同步到 shadow copy 后统一扫描 |
| **Finalizer 列表**           | 带终结器对象的指针         | 作为灰节点入队                               |
| **cgo / 外部句柄表**            | 在 C 代码中持有的 Go 指针  | 通过 `cgo.Handle` 映射表纳入 GC 跟踪           |

> GC 将上述根的指针槽全部置为灰色，随后进入三色标记流程：灰→扫描→黑；只有位图标 1 的槽才会继续递归，值槽被直接跳过。

---

#### 2. 编译期逃逸分析

| 判断条件                      | 去向    | 代码片段                                 |
| ------------------------- | ----- | ------------------------------------ |
| 地址跨栈帧泄露 / 闭包捕获            | **堆** | `return &x`, `go func(){x}()`        |
| 存入接口 / map / slice / chan | **堆** | `m[k] = &x`, `any(&x)`               |
| 对象大小 > 64 KB              | **堆** | `[1<<20]byte{}`                      |
| 可能 `append` 触发扩容          | **堆** | `s := make([]T,0); s = append(s, v)` |
| 编译器能证明「小且局部」              | **栈** | `buf := make([]byte, 0, 8)`          |

```bash
# 查看逃逸输出
go build -gcflags="-m" ./...
```

---

#### 3. 堆内分配层级

| 对象特征        | 分配路径                     | 典型开销               |
| ----------- | ------------------------ | ------------------ |
| ≤ 16 B 且无指针 | **Tiny Allocator**       | 极低（打包至 16 KB Span） |
| ≤ 32 KB     | **MCache（Per‑P）**        | O(1)——无锁本地缓存       |
| > 32 KB     | **MHeap / Large Object** | 需要全局锁，频率低          |

> **MCache → MCentral → MSpan**：逐级下发，减少锁竞争；空闲 Span 由 **Scavenger** 归还操作系统。全局 GC 使用三色并发标记‑清扫。

---

#### 4. 可增长栈

* 初始仅 **2 KB**，不足时触发 `morestack`，复制到更大的栈段。
* 当顶部空闲 ≥ 75 % 时可收缩。
* 栈内对象不受 GC 追踪，按栈帧生命周期自动销毁。

---

#### 5. 调优速查表

| 症状            | 诊断工具                               | 主要着力点                                    |
| ------------- | ---------------------------------- | ---------------------------------------- |
| GC 占用高 / 内存抖动 | `pprof heap`, `go test -benchmem`  | 复用 `sync.Pool` · 提前 `make(cap)` · 拆分大对象  |
| 逃逸过多          | `go build -gcflags="-m"`           | 减少接口 / 闭包；循环变量局部化；优先值接收器                 |
| RSS 膨胀        | `pprof heap_inuse` vs. `heap_idle` | 提高 `GOGC`、设置 `GOMEMLIMIT`、使用 Go 1.22 堆封顶 |
| 大对象碎片         | trace Timeline, heap profile       | 预分大 Buffer 并复用 · 流式处理 · 使用 mmap          |

---

#### 6. 总结

> **“静态常驻区、局部先上栈、跨域才上堆；
> 写时才占页，空闲可还 OS；
> 编译器判逃逸，运行时分小中大；
> 复用减 GC，高频找热点。”**

牢记这四行，你就掌握了 Go 内存模型、虚拟内存映射与常见调优抓手。


## 同步原语
暂时没有很好的想法；


## channel(CSP)

> 1. “共享内存” → “通过通信来共享内存”  —— CSP 的核心口号
> 2. Channel = 有容量的“信箱” + 发送 / 接收双方的“门铃”
> 3. 每一次 send/recv 都是一次隐式的同步点**，调度器利用它做阻塞 / 唤醒**

### 为什么使用CSP
| 传统模型                  | 问题                | Channel (CSP) 的对策                       |
| --------------------- | ----------------- | --------------------------------------- |
| 多线程 + 数据共享 + 加锁       | 易出错：死锁、竞态、锁粒度难拿捏  | 不共享数据，**把数据打包进消息**；线程（goroutine）之间只交换消息 |
| 手动 `select/poll` 事件循环 | 业务逻辑与事件处理混在一起，难维护 | Channel 自带阻塞和就绪，`select` 把事件组合写得像同步代码   |

### 抽象是什么？——“信箱＋门铃”
```scss
┌─────────── Channel (cap=N) ────────────┐
│ 队列区  [ msg0 | msg1 | ... ]          │ ← 信箱：缓存数据
│ 等待队列 sendq:  G1 G2 ...             │ ← 发送方排队
│ 等待队列 recvq:  G3 G4 ...             │ ← 接收方排队
└────────────────────────────────────────┘
```
- 容量 cap 决定是否需要排队：

  cap=0 ⇒ 同步信道：必须“面对面”交换；

  cap>0 ⇒ 缓冲信道：像投递信箱，有空位就直接放。

- sendq / recvq 存的是休眠的 Goroutine 指针。

  当 send 遇到空闲 recv，两边直接 “配对交换” → 互相唤醒；

  否则把 G 挂到队列，由调度器 park，等待对方来“敲门”。

###  一条 send/recv 的完整路径
1. 发送方 Gₛ 调用 chansend

        尝试配对：先看 recvq 是否有人在等。

        有就无拷贝直送：把数据写到接收者栈，唤醒对方，返回。

        没人且队列未满 → 把数据放进 ring buffer，返回。

        队列已满 → 挂到 sendq，gopark() 阻塞。

2. 接收方 Gᵣ 调用 chanrecv

        先看缓冲区有没有数据 → 取数据，返回。

        无数据但 sendq 有人排队 → 与发送方配对，直接拷贝，唤醒对方。

        都没有 → 把自己挂到 recvq，gopark()。

- 关键点：配对优先于缓冲，确保零拷贝且唤醒及时。

### select 如何做到“任意一个就绪”
1. 编译器把 select { case ch1 <- v; case v2 := <-ch2 }
展开为 乱序探测 + 逐 case 尝试配对。

2. 任意 case 成功就返回；全部失败 → 当前 G 掛到每个候选 channel 的队列里，gopark 阻塞。

3. 其中某个 channel 就绪时，只要看到某 G 在它的 case 链表上，就把该 G 唤醒并告知“是第 k 条 case 中的事件”。

连锁好处：

- 不需要手动管理 epoll；

- 多路就绪逻辑写得像同步代码；

- 调度器仍能充分复用系统线程。

### 数据拷贝情况
> 放进缓冲区的是 “元素本身的一份拷贝”——而不是发送端某块内存的地址。  
> Go 在创建 make(chan T, n) 时，已经为 n 个元素各预留了一段大小等于 unsafe.Sizeof(T) 的环形缓冲区；发送时 runtime 用 memmove 把数据复制到当前写指针指向的那段内存中。


| 发送的值                    | 实际拷贝内容                          | 内存关系                       |
| ----------------------- | ------------------------------- | -------------------------- |
| 基本值（int、float、struct 等） | 整个值字节序列                         | 缓冲区内有该值独立副本                |
| 指针 / slice / map / chan | **指针本身**（8B/64bit）              | 指针指向的底层数据不复制，发送者与接收者共享那块内存 |
| interface{}             | 两个 machine-word：type指针 + data指针 | data 指针指向的对象同样共享           |

  > 因此：“是否重新分配内存”取决于元素类型：
  >
  > - 发送基本类型、大 struct ⇒ 值复制，缓冲区占完整大小。
  >
  > - 发送指针或 slice ⇒ 只复制指针，大对象仍在堆上，共享。

#### 配对直传的特殊情况
在无缓冲信道或缓冲满/空触发“直接配对”时，runtime 不会先写缓冲区，而是把数据 一次性拷贝到接收方栈（同样是 memmove）。这减少了一次中转，但“拷贝 vs 指针”原则与上表一致。

#### 性能提示
1. 大对象用指针  
  chan *BigStruct 避免每次 memmove 大块内存。

2. 大量短消息可调小 cap  
   减少缓冲占用与复制量。

3. **切片仍需注意共享写  **
    **发送 []byte 后两端共享底层数组，写前须 copy 以免数据竞态。**